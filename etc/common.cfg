#!/bin/bash
myNameIs=${0##*/}
myPathIs=${0%/*}

#################################
#
#  version: 0.0.3.0029
#  date: 10.12.2018
#  mod': 05.02.2019
#  Copyright Tommi Nikkilae 2018
#  url: http://f8.oire.fi/blog (techy things)
#  url: http://f8.oire.fi/ (my photos)
#  email: f8@oire.fi
#  Released under GNU GPLv3
#
#################################

#################################
#
#  ext.conf
#
confErr() {
	case $1 in
		5)
			msg="File $1 not found. This is fatal error. Die."
			;;
		50)
			msg="Unable to write to $lockdir/. This is fatal error. Die."
			;;
		*)
			msg="Unknown error occured. Die."
			;;
	esac
	echo "$msg"
	logger "$myNameIs :: [CRITICAL] :: $msg"
	exit 1
}
	[ -z "$logging" ] && logging=3
	[ -z "$debug" ] && debug=0
	if [ "$debug" -gt "0" ]; then
		debugInfo="$myNameIs :: [TRACE] :: I am $myPathIs/$myNameIs"
		[ "$logging" -gt "0" ] && logger "$debugInfo [logging: ENABLED]" || logger "$debugInfo [logging: DISABLED]"
	fi
#
#  see if /lockdir/ is writable. if not, die
#
	lockdir="/lockdir"
	[ ! -w "$lockdir" ] && confErr 50
#
#  Our default incl. path is /your/script's/path/ + etc/|sbin/|[etc.]
#  See if the configuration files are found there. If not, 
#  use the global default /usr/local/ + etc/|sbin/|etc.
#
	if [ -f "$myPathIs/etc/shellcommands.cfg" ]; then
		if [ -f "$myPathIs/etc/errors.cfg" ]; then
			incPath="$myPathIs"
		else
			incPath="/usr/local"
		fi
	else
		incPath="/usr/local"
	fi
#
#  shell commands
#
	conFile="$incPath/etc/shellcommands.cfg"
	[ -r "$conFile" ] && . "$conFile" || confErr 5 "$conFile"
#
#  err()
#
	conFile="$incPath/etc/errors.cfg"
	[ -f "$conFile" ] && . "$conFile" || confErr 5 "$conFile"
#
#
#  read/load configuration option specific to this script (if found)
	confFile="$incPath/etc/conf/$myNameIs.conf"
	if [ -f "$confFile" ]; then
		. "$confFile" && logger "$myNameIs :: [DEBUG] :: read $confFile" || logger "$myNameIs :: [WARNING] read $confFile FAILED."
	else
		[ "$debug" -gt "0" ] && logger "$myNameIs :: [DEBUG] $confFile not found. This is not an error."
	fi
#
#  ext. conf end
#
#################################
#################################
#
#  Use trap when locking the script from running multiple sessions
#  or at least running any real actions multiple times
	lock="$lockdir/."$myNameIs".lock"
	if ! ${SH_MKDIR} "$lock" &> /dev/null; then
		if [ "$force" = "1" ]; then
			# attempt to remove and check again
			if ! ${SH_RMDIR} "$lock" &> /dev/null; then
				${SH_LOGGER} "$myNameIs :: [CRITICAL] :: Script already running. Exiting."
				exit 1
			elif ! ${SH_MKDIR} "$lock" &> /dev/null; then
				${SH_LOGGER} "$myNameIs :: [CRITICAL] :: Script already running. Exiting."
				exit 1
			else
				${SH_LOGGER} "$myNameIs :: [DEBUG] :: Acquired lock. Continue."
			fi
		fi
	fi
#	chmod 700 "$lock"
#	if ! ${SH_CHOWN} 777 "$lock" &> /dev/null; then
#		${SH_LOGGER} "$myNameIs :: Unable to change access rights to '$lock'. Exiting."
#	fi
	trap 'rm -rf $lock' EXIT  # remove the lockdir on exit

#################################
#
#  Check if root privileges are required
#  and if they are exit if user is not root
#  NOTE! The notion is that ALL scripts must
#  be defined as NOT to require root privileges
#  or root privileges will be needed.
#
	[ -z "$rootRequired" ] && rootRequired=1
	if [ "$rootRequired" = "1" ]; then
		if [ "$EUID" -ne "0" ]; then
			${SH_ECHO} "This script must be run as root"
			exit 1
		fi
	fi
#
#
#################################

#################################
#
#  If you want errors to kill the script, use
#	errKills=1
#  else the exit code is just returned from function with
#	errKills=0
#  If nothing is defined, we use 1 (enabled)
	[ -z "$errKills" ] && errKills=1
#
#
#################################

#################################
#
#  Debugging setup. Defines if more messages are displayed/pushed.
#  If nothing is defined, we use 3 (INFO)
#
	[ -z "$debug" ] && debug=0
	[ "$1" = "--test" ] && debug=1 && ${SH_ECHO} "Debugging mode enabled."
	if [ "$debug" -gt "0" ]; then
#		SH_LOGGER="/bin/echo"
		SH_PUSHBULLET="/bin/echo"
	fi
#
#################################

#################################
#
#  Define if push notifications are sent or not
#
#  Here we define the default behaviour. If you set
#  	push=1
#  within your script, the script's config file
#  or from the command line (if the script takes
#  arguments) it will override this by design.
#
	push=0
#
#  Define the minimum time between push notifications
#  The default is 15 mins so push notifications
#  would not colg up the system or recipient's device.
#
	[ -z "$minNotifyIntervalInMinutes" ] &&	minNotifyIntervalInMinutes=15
#
#################################

#################################
#
#  Common variables setup
#
	myWholeNameIs=${0}
	myArguments=${@}
	title="$HOSTNAME [$myNameIs]"
	declare -g trckErr
	trckErr="/lockdir/."$myNameIs".err.lock"
	sleep=10
	randomString=$(${SH_CAT} /dev/urandom | ${SH_TR} -dc 'a-zA-Z0-9' | ${SH_FOLD} -w 16 | ${SH_HEAD} -n 1)
	tmpFile="/tmp/"$randomString
	sTime=$(${SH_DATE} +'%s')
	OFFSET=$(date +%z)
	SIGN=${OFFSET:0:1}
	HOURS=${OFFSET:1:2}
	MINUTES=${OFFSET:3:2}
	EPOCH=$(date +%s)
	sConvTime=$(( ${sTime} ${SIGN} ( ${HOURS} * 3600 + ${MINUTES} * 60 ) ))
	logdate=$(${SH_DATE} -d @"$sTime" +'%d.%m.%Y %H:%M:%S')
	waitThisLong=$(( minNotifyIntervalInMinutes * 60 ))
	usageMessagePath="$myPathIs/etc/usg"
	usageMessageFile=$usageMessagePath"/"$myNameIs".usg"
#
#
#  Common variables setup end
#
#################################

#################################
#
#  Set some more [local] variables
#
#################################

#################################
#
#  Functions begin here
#
usage() {
	[ -e "$usageMessageFile" ] && usageMessage=$(<$usageMessageFile)
	[ -z "$usageMessage" ] && usageMessage=' [No additional help provided. Sorry.]'
	usageMessage="Usage: "$myNameIs" "$usageMessage"\n"
	${SH_ECHO} -e "$usageMessage"
	exit 1
}

logThis() {
#	We use different log levels, mainly: 
#		1 or [C|c]ritical
#		2 or [W|w]arning
#		3 or [I|i]nfo (as default, if no log level is defined)
#		4 or [D|d]ebug
#		5 or [T|t]race
#
#	When logging, use logLevels as:
#
#	logThis "Your message." "logLevel"
#	eg.
#	logThis "Something happened. Call anybody for help even at 2AM!" "C"
#	logThis "Device unavailable. Skipping." "w"
#	logThis "Event completed successfully." "I"
#	logThis "Configuration file not found. Using defaults." "d"
#	logThis "Parsing variables, var #3 has value..." "t"
#
#	!NOTE! If loggin is set to '0', nothing is logged with
#	the exception of CRITICAL or [C|c] which is ALWAYS logged.
#
#	Configuration option "logging" is used to log messages of logLevel or lower.
#	At logging=1 we will log only messages with Critical logLevel, at logging=3
#	we will log messages of logLevel Critical, Warning and Info, etc.
#	Default is 3.
#
	forceLogging=0
	case $2 in
		"C"|"c"|1 ) #critical
			logInfo="CRITICAL"
			logLevel=1
			forceLogging=1
			;;
		"W"|"w"|2 ) #warn
			logLevel="WARNING"
			logLevel=2
			;;
		"I"|"i"|3 ) #info
			logLevel=3
			logInfo="INFO"
			;;
		"D"|"d"|4 ) #debug
			logLevel=4
			logInfo="DEBUG"
			;;
		"T"|"t"|5 ) #trace
			logLevel=5
			logInfo="TRACE"
			;;
		* ) #info
			logInfo="INFO"
			logLevel=3
			;;
	esac


	if [ "$logging" -gt "0" ]; then
		[ "$logging" -ge "$logLevel" ] && ${SH_LOGGER} "$myNameIs :: [$logInfo] :: $1"
	elif [ "$forceLogging" -eq "1" ]; then  #Always log CRITICAL level messages
		${SH_LOGGER} "$myNameIs :: [CRITICAL] :: $1"
	fi
}

ntfy() {
	[ -z "$2" ] && title=$2

	###################################################################################################
	#
	#  Use PushBullet with care: you can easily flood a recipient with
	#  infinite number of messages if ntfy() is run from err() and
	#  script is scheduled to run every x mins or so... I use a coarse file-named-with-ID as identity 
	#  placed in /lockdir/ for keeping track if a PushBullet msg has already been sent.
	#  Make sure $trckErr is unique but not too much (so it will still be recognized by the script).
	#
	#  ${SH_LOGGER} "$myNameIs :: $1"
	#  fNm=$(${SH_ECHO} $1|${SH_TR} -d '/')
	#  trckErr="/lockdir/"$myNameIs"-"$fNm # or leave undefined for default (see above)
	#  [[ -f "$trckErr" && "$timeDiff" -gt "$waitThisLong" ]] && ${RM} -f $trckErr ||  err "4" "$timeDiff"
	#
	###################################################################################################

	###################################################################################################
	#
        # Not all ntfy's are created equal. If "push" is set 0 (default value) no PushBullet is launhced.
	if [ "$push" -gt "0" ]; then
		if [ ! -e "$trckErr" ]; then
		${SH_TOUCH} $trckErr
			if [ -e "$trckErr" ]; then
				logThis "Lock file ($trckErr) created for push notifications."
			else
				err "1" "$trckErr"
			fi

			###################################################################################
			#
			#  The default errKills value (=1) takes care of killing the script before any
			#  PushBullet msg is sent but if you change the errKills value to 0
			#  this will no longer happen and you will flood error message
			#  because there is no trckErr file and one cannot be created!
			#
			#  This is needed for *$debug* as the default usage of PushBullet in script
			#  requires suppressing all output. This combined with *$debug* makes the
			#  SH_PUSHBULLET echo it's variables to /dev/null. So, if debug is enabled (>0) 
			#  we'll logThis instead. Great success!
			#
			###################################################################################

			if [ "$debug" -gt "0" ]; then
				[ "$push" -gt "0" ] && ${SH_PUSHBULLET} "$1" "$title" &> /dev/null || logThis "$1" "$2"
			else
				${SH_PUSHBULLET} "$1" "$title" &> /dev/null
			fi
		fi
	fi
	[ "$debug" -gt "0" ] && ntfMsg="[DEBUG MODE] "$1 || ntfMsg=$1
	[ "$debug" -gt "0" ] && logThis "$ntfMsg" "$2"
	#
	###################################################################################################

}

getDHTread() {
	logThis "getDHTread() here, hello!"
        case $1 in
                hum )
			column=3
			;;
                temp )
			column=2
			;;
		* )
			err
			;;
	esac
	# This is here until we get our /usr/local/sbin/DHTXXD to function properly...
	SH_DHT="/usr/local/sbin/DHTXXD-exec"

	DHT22raw=$(${SH_DHT})
	DHT22status=$(${SH_ECHO} "$DHT22raw"|${SH_CUT} -d " " -f 1)
	DHT22res=$(${SH_ECHO} "$DHT22raw"|${SH_CUT} -d " " -f $(${SH_ECHO} "$column"))

	logThis "raw: $DHT22raw"
	logThis "status: $DHT22raw"
	logThis "res: $DHT22raw"

	i=0
	sleep=2
	maxIters=5

#	logThis "DHT22 read iteration $i"

	while [ "$DHT22status" -gt "0" ]; do
		if [ "$i" -ge "$maxIters" ]; then
			iterSecs=$(echo "scale=0; ($i*$sleep)/1"|bc -l)
			logThis "Read error from DHT22. Error count: $i of $maxIters [$iterSecs sec(s)]). Read: (\$in) '$DHT22res', (\$DHT22status) '$DHT22status'." "C"
			err 19 "stat: $DHT22status, read: $DHT22res"
			break
			exit 1
		fi

		${SH_SLEEP} $sleep
##		in=$(${SH_DHT}|${SH_CUT} -d " " -f 2)
		logThis "DHT22 read iteration $i"
		DHT22raw=$(${SH_DHT})
		DHT22res=$(${SH_ECHO} "$DHT22raw"|${SH_CUT} -d " " -f $(${SH_ECHO} "$column"))
		DHT22status=$(${SH_ECHO} "$DHT22raw"|${SH_CUT} -d " " -f 1)
		[ "$DHT22status" -eq "0" ] && logThis "Read error from DHT22 recovered; stat: $DHT22status, read: $DHT22res"
		(( i++ ))
	done
	title="DHT22"
	z=$(${SH_ECHO} "scale=1;$(${SH_ECHO} $DHT22res)/1" | bc -l)
	${SH_ECHO} "$z"
}

function convertTimeStampEpoch() {
	# human to epoch (eg. "Apr 28 07:50:01" to 1524916201)
	res=$(date -d "${1}" +"%s")
	${SH_ECHO} $res
}

function convertTimeStampHuman() {
	# epoch to human (eg. 1524916201 to "26.11.1970 07:50:01")
	res=$(date -d "@${1}" +"%d.%m.%Y %H:%M:%S")
	${SH_ECHO} $res
}

function convertTimeStampHumanZeroed() {
	# epoch to human (eg. 1524916201 to "26.11.1970 07:50:01")
	res=$(date -d "@${1}" +"%d.%m.%Y %H:%M")
	${SH_ECHO} $res
}

floatToInt() {
	${SH_PRINTF} "%.0f\n" "$1"
}

round() {
	[[ -z "$1" || -z "$2" ]] && err 30
	decimals=$(${SH_ECHO} ${2#-})
	[ "$decimals" -gt "4" ] && decimals=4
	res=$(${SH_AWK} 'BEGIN{printf "%.'"$decimals"'f\n", ('"$1"')}')
	${SH_ECHO} $res
}

show_versions() {
	/usr/local/sbin/sh.versions
}

versionHandler() {
	${SH_ECHO} "$@" | ${SH_AWK} -F. '{ printf("%d%03d%03d%03d\n", $1,$2,$3,$4); }';
}

transfer() {
	username=$3
	host=$4
	[ -z "$1" ] && err 10 "source"
	[ ! -e "$srcFile" ] && err 8 "$srcFile"
	tryCount=0
	tryLimit=10
	${SH_SCP} -Bq $1 $3@$4:$2
	while [ "$?"  -ne "0" ]; do
		${SH_SCP} -Br $1 $3@$4:$2
		[ "$tryCount" -le "$tryLimit" ] || err 9 "$1"
		(( tryCount +1 ))
		${SH_SLEEP} 1
	done
}

transfer_debug() {
	username=$3
	host=$4
	[ -z "$1" ] && err 10 "source"
	[ ! -e "$srcFile" ] && err 8 "$srcFile"
	${SH_ECHO} "${SH_SCP} -Bq $1 $3@$4:$2"
}

checkDep() {
	[ "$debug" -gt "0" ] && logThis "Checking dependency for $1..."
	if [ -e "$1" ]; then
		[ "$debug" -gt "0" ] && logThis "Dependency $1 found. It is safe to continue."
	else
		err 5 "$1"
	fi
}

function displaytime {
	local T=$1
#	local Y=$((T/60/60/24/365))
	local D=$((T/60/60/24))
	local H=$((T/60/60%24))
	local M=$((T/60%60))
	local S=$((T%60))
#	(( $Y > 0 )) && ${SH_PRINTF} '%d years ' $Y
	(( $D > 0 )) && ${SH_PRINTF} '%d days ' $D
	(( $H > 0 )) && ${SH_PRINTF} '%d hours ' $H
	(( $M > 0 )) && ${SH_PRINTF} '%d minutes ' $M
	(( $D > 0 || $H > 0 || $M > 0 )) && ${SH_PRINTF} 'and %d seconds\n' $S || ${SH_PRINTF} '\e[0;33m%d seconds\e[0m\n' $S
#(( $D > 3 )) && dWarn=1

xT=$(( $sTime - $ntfHr * 3600))
lT=$(( $sTime - $T))

(( $xT > $lT )) && hWarn=1 || hWarn=0
return "$hWarn"
}

scriptEnd() {
	##################################################################
	#
	#  Destroy notify lock. Errors will exit program early
	#  so if the script survived here, all is well and notify
	#  lock can be removed if $waitThisLong seconds
	#  have passed. $waitThisLong is to stop error messages
	#  from flooding the recipient.
	#
	[ -f "$trckErr" ] && mTime=$(${SH_STAT} -c %Y "$trckErr") || mTime=0
	timeDiff=$(( sTime - mTime ))
	if [ -a $trckErr ]; then
		[ "$timeDiff" -ge "$waitThisLong" ] && ${SH_RM} -f $trckErr || err "4" "$timeDiff"
	fi
	ntfy "$msg" "$title"
	#
	##################################################################

	#endTme=$(date +%s.%N)
#	dt=$(${SH_ECHO} "$endTme - $strtTme" | bc)
#	dd=$(${SH_ECHO} "$dt/86400" | bc)
#	dt2=$(${SH_ECHO} "$dt-86400*$dd" | bc)
#	dh=$(${SH_ECHO} "$dt2/3600" | bc)
#	dt3=$(${SH_ECHO} "$dt2-3600*$dh" | bc)
#	dm=$(${SH_ECHO} "$dt3/60" | bc)
#	ds=$(${SH_ECHO} "$dt3-60*$dm" | bc)
#	printf "Total runtime: %d:%02d:%02d:%02.4f\n" $dd $dh $dm $ds
	#${SH_LOGGER} "Total runtime: %d:%02d:%02d:%02.4f\n $dd $dh $dm $ds"
	exit 0
}
#
# Functions end.
#
#################################
