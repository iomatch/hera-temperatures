#!/bin/bash
strTime=$(date +'%s.%N')
commonStartTime=$(/bin/date +'%s.%N')
#################################
#
#  version: 1.3.4
#  date: 10.12.2018
#  mod': 10.12.2022
#  Copyright Tommi Nikkilae 2018
#  url: http://f8.oire.fi/blog (techy things)
#  url: http://f8.oire.fi/ (my photos)
#  email: f8@oire.fi
#  Released under GNU GPLv3
#
#################################

myNameIs=${0##*/}
myPathIs="${0%/*}"
binPath="/home/pi/bin"
exitCode=0
pushErrors=0
cloudLogAllowed=1
b2bErrMax=2
tmpF="$myPathIs/${myNameIs}"
[[ -r "$tmpF" ]] && srcVersion=$(head -10 "$tmpF"|grep "version"|tail -1|tr -d ' '|cut -d ':' -f 2) || srcVersion="n/a"
logger "$myNameIs ($$) :: [ INFO: 3/3] :: $myNameIs v. $srcVersion started..."
tmpF="$myPathIs/etc/common.cfg"
[[ -r "$tmpF" ]] && cmmVersion=$(head -10 "$tmpF"|grep "version"|tail -1|xargs|cut -d " " -f 3)
trckErr="/lockdir/.$myNameIs.pushLock"
currUser=$(/usr/bin/whoami)
persistentTempDirectory="/var/tmp/hrmk-bashes"
curlFile="${persistentTempDirectory}/curlFile"
uptimeInSecs=$(cat /proc/uptime |cut -d " " -f 1 | cut -d "." -f 1|awk '{print int($1+0.5)}')
[[ -z "${mqttQueue}" ]] && mqttQueue="kanala/relay-control"

# Sometimes $HOME is not defined, set default here:
[[ -z "${HOME}" ]] && USER_HOME="/home/pi/" || USER_HOME="${HOME}"

#################################
#
#  ext.conf
#
confErr() {

	RED='\033[0;31m'
	NC='\033[0m' # No Color

	case $1 in
		1)
			msg="Unable to create lock file. Check access rights on $lockdir/ and try again."
			outmsg="Unable to create lock file. Check the access rights on ${RED}$lockdir/${NC} and try again."
			;;
		2)
			msg="Unable to create temporary directory for scripts. Check access rights on ${persistentTempDirectory}/ and try again."
			outmsg="Unable to create temporary directory for scripts. Check the access rights on ${RED}${persistentTempDirectory}/${NC} and try again."
			;;
		3)
			msg="Access denied for ${persistentTempDirectory}/ for user '$currUser'. Check access rights on ${persistentTempDirectory}/ and try again."
			outmsg="Access denied for ${persistentTempDirectory}/ for user '$currUser'. Check access rights on ${RED}${persistentTempDirectory}/${NC} and try again."
			;;
		5)
			msg="Unable to read configurations from '$2'. This is fatal error. Die."
			;;
		*)
			msg="Unknown error occured. Die."
			;;
	esac
	[ -z ${outmsg+x} ] && echo -e "$msg" || echo "$outmsg"
	logger "$myNameIs ($$) :: [ CRIT: 1/$logging] :: $msg"
	exit $1
}
#	[ -z "$logging" ] && logging=4
#	[ -z "$logging" -eq "1" ] && logging=4
	logging=4
	[ -z "$debug" ] && debug=0
	if [ "$debug" -gt "0" ]; then
		debugInfo="$myNameIs ($$) :: [TRACE: 5/$logging] :: I am $myPathIs/$myNameIs"
		[ "$logging" -ge "5" ] && logger "$debugInfo [logging: ENABLED, debug mode]" #|| logger "$debugInfo [logging: DISABLED]"
	fi
#
#  see if /lockdir/ is writable. if not, die
#
	lockdir="/lockdir"
	[ ! -w "$lockdir" ] && confErr 1
#
#  Our default incl. path is /your/script's/path/ + etc/|sbin/|[etc.]
#  See if the configuration files are found there. If not, use the global default /usr/local/ + etc/|sbin/
#
#	if [ -f "$myPathIs/etc/shellcommands.cfg" ]; then
		if [ -r "$myPathIs/etc/errors.cfg" ]; then
			incPath="$myPathIs"
		else
			incPath="/home/pi/bin"
		fi
#	else
#		incPath="/usr/local"
#	fi
#
#  read/load configuration option specific to this script (if found)
	[[ -d "${incPath}/etc/conf/${HOSTNAME}" ]] && confPath="conf/${HOSTNAME}" || confPath="conf"
	for confFile in	"${incPath}/etc/${confPath}/common.conf" "${incPath}/etc/${confPath}/$myNameIs.conf"; do
		if [ -f "$confFile" ]; then
			if . "$confFile"; then
				[ "$logging" -ge "4" ] && logger "$myNameIs ($$) :: [DEBUG: 4/$logging] :: Configuration file $confFile read."
			else
				[ "$logging" -ge "2" ] && logger "$myNameIs ($$) :: [WARN!: 2/$logging] :: read $confFile FAILED!"
			fi
		else
			[ "$logging" -ge "5" ] && logger "$myNameIs ($$) :: [TRACE: 5/$logging] :: Configuration file $confFile not found. This is not an error."
		fi
		[ "$forceLogging" == "true" ] && logging=5
	done
	chkMsg="$myNameIs ($$) :: [DEBUG: 4/$logging] :: Checked for 'userConfFile' (${incPath}/etc/${confPath}/${myNameIs}.conf):"
	if [[ -r "${incPath}/etc/${confPath}/${myNameIs}.conf" ]]; then
		userConfFile="${incPath}/etc/${confPath}/${myNameIs}.conf"
		[ "$logging" -ge "4" ] && logger "${chkMsg} file found."
	else
		[ "$logging" -ge "4" ] && logger "${chkMsg} file not. This is OK, defaults will be used instead."
	fi
	unset chkMsg
	logger "$myNameIs ($$) :: [TRACE: 5/$logging] :: Loglevel: $logging"

#
#  shell commands
#
	confFile="$incPath/etc/shellcommands.cfg"
	if . "$confFile"; then
		 [ "$logging" -ge "5" ] && logger "$myNameIs ($$) :: [TRACE: 5/$logging] :: read shell commands from $confFile"
	else
		confErr 5 "$confFile"
	fi
#	[ -f "$confFile" ] && . "$confFile" || confErr 5 "$confFile"
#
# for lock file handling
	chkTime=$(date +'%s')
	[[ -z "$giveUp" ]] && giveUp=5
	[[ -z "$chkSleeep" ]] && chkSleeep=5
#
#
#  err()
#
	errConfFile="$incPath/etc/errors.cfg"
	#[[ "$debug" -gt "0" ]] && errConfFile="$incPath/etc/errors.cfg"
	[[ -r "${errConfFile}" ]] && errVersion=$(head -10 "$errConfFile"|grep "version"|tail -1|xargs|cut -d " " -f 3)
	if . "$errConfFile"; then
		[ "$logging" -ge "5" ] && logger "$myNameIs ($$) :: [TRACE: 5/$logging] :: read error handling from $errConfFile"
	else
		confErr 5 "$errConfFile [$errVersion]"
	fi
#
#  see if $persistentTempDirectory exists. if not, try
#  to create it and make it writable for anyone. if this fails, err
#
	if [ ! -d "${persistentTempDirectory}" ]; then
		mkdir -p "${persistentTempDirectory}" || confErr 2
		chmod -R 777 "${persistentTempDirectory}" || confErr 3
	fi
#
#  see if $persistentTempDirectory is writable. if not, die
#
	[ ! -w "${persistentTempDirectory}" ] && confErr 3
#
#  ext. conf end
#
#################################

logThis() {
#	We use different log levels, mainly:
#		1 or [C|c]ritical
#		2 or [W|w]arning
#		3 or [I|i]nfo (as default, if no log level is defined)
#		4 or [D|d]ebug
#		5 or [T|t]race
#
#	When logging, use logLevels as:
#
#	logThis "Your message." "logLevel" "$FUNCNAME"
#	The "$FUNCNAME" is optional. It provides users with more information by logging the name of function
#	calling for logThis().
#	eg.
#	logThis "Something happened. Call anybody for help even at 2AM!" "C" "$FUNCNAME"
#	logThis "Device unavailable. Skipping." "w" "$FUNCNAME"
#	logThis "Event completed successfully." "I"
#	logThis "Configuration file not found. Using defaults." "d" "$FUNCNAME"
#	logThis "Parsing variables, var #3 has value..." "t"
#
#	!NOTE! If loggin is set to '0', nothing is logged with
#	the exception of CRITICAL or [C|c] which is ALWAYS logged.
#
#	Configuration option 'logging' is used to define messages of logLevel or lower to actually write to syslog.
#	At logging=1 we will log only messages with Critical logLevel, at logging=3 we will log messages of
#	logLevel Critical, Warning and Info, etc.
#	Default: logging=3.
#
	forceLogging=0
	unset errInfo #debugLogging
	debugInf="!DBG!"
	case $2 in
		"C"|"c"|1 ) #critical
			errInfo="CRITICAL!"
			logInfo="!CRIT"
			localLogLevel=1
			forceLogging=1
			;;
		"W"|"w"|2 ) #warn
			errInfo="WARNING!"
			logInfo="WARN!"
			localLogLevel=2
			;;
		"I"|"i"|3 ) #info
			logInfo=" INFO"
			localLogLevel=3
			;;
		"D"|"d"|4 ) #debug
			logInfo="DEBUG"
			localLogLevel=4
			;;
		"T"|"t"|5 ) #trace
			logInfo="TRACE"
			localLogLevel=5
			;;
		"X"|"x"|"debug") #debug
			logInfo="${debugInf}"
			localLogLevel=4
			#debugLogging="1"
			;;
		* ) #info
			logInfo=" INFO"
			localLogLevel=3
			;;
	esac

	[[ "$localLogLevel" -le "2" ]] && logger -s "$errInfo ${myNameIs}: ${1}."

	[[ "${debugLogging}" -eq "1" ]] && localLogLevel=5

	if { [[ "$logging" -ge "$localLogLevel" && "${logInfo}" != "${debugInf}" ]]; } || [[ "$forceLogging" -eq "1" ]] || [[ "${debugLogging}" -eq "1" ]]; then
#		if { [[ "${debugLogging}" -eq "1" && "${debug}" -eq "1" ]]; } || [[ "${debugLogging}" -ne "1" ]]; then
			S1=" :: "
			S2=" oo "
			logMsg="$myNameIs ($$)$S1"
			[ -z ${3+x} ] && logMsg=$logMsg"[$logInfo: $localLogLevel/$logging]$S1" ||  logMsg=$logMsg"[$logInfo: $localLogLevel/$logging]$S2"
			[ -z ${3+x} ] || logMsg=$logMsg"$3()$S1"
			logMsg="$logMsg$1"
			${SH_LOGGER} "$logMsg"
#		fi
	fi
}

displaytime() {
	if [[ ! -z "$1" ]]; then
		# usage:
		# displaytime $1 [$2]
		# displays $1 seconds in a human readable format (day(s), hour(s), minute(s), second(s)[, millisecond(s)])
		unset millis
		#[[ ! -z "$2" ]] && local millis=$2
		local T="$1"
		if [[ ! -z "$(echo $T|grep '\.')" ]]; then
#			logThis "${T} contains ." "T" "${FUNCNAME}"
			millis=$(echo "${T}"|cut -d "." -f 2)
			T=$(echo "${T}"|cut -d "." -f 1)
#		else
#			millis="0000"
		fi
		local D=$((T/60/60/24))
		local H=$((T/60/60%24))
		local M=$((T/60%60))
		local S=$((T%60))

#		logThis "Local vars: D: $D, H: $H, M: $M, S: $S, ms: $millis" "T" "${FUNCNAME}"
		[[ ! -z "$millis" ]] && local Ss="$S.$ms"


		(( $D > 1 )) && printf '%d days' $D
		[[ $D -eq 1 ]] && printf '%d day' $D

		[[ "$D" -ge "1" && "$H" -ge "1" ]] && printf " "
		(( $H > 1 )) && printf '%d hours' $H
		[[ $H -eq 1 ]] && printf '%d hour' $H

		[[ "$H" -ge "1" && "$M" -ge "1" ]] && printf " "
		(( $M > 1 )) && printf '%d minutes ' $M
		[[ $M -eq 1 ]] && printf '%d minute ' $M

		[[ -z "$millis" ]] && printf '%s seconds\n' "$S" || printf '%s seconds\n' "$S.$millis"
	else
		logThis "No \$1 provided. Nothing to process." "D" "$FUNCNAME"
		echo " [ UNKNOWN ]"
	fi
}

trackTime() {
#	if [[ "$1" ]] && [[ "$2" ]] && [[ "$3" ]]; then
	if [[ "$1" ]] && [[ "$2" ]]; then
		unset timeElapsed functionSeconds functionMilliseconds tmpT var
		timeElapsed=$(echo "scale=4;(${2} - ${1})/1"| bc -l)
		functionSeconds=$(echo "$timeElapsed" | cut -d "." -f 1)
		functionMilliseconds=$(echo "$timeElapsed" | cut -d "." -f 2)
		logThis "Paramaters given: '$1', '$2', '$3'. Seconds: '$functionSeconds', time elapsed: '$functionMilliseconds'." "X" "${FUNCNAME}"
#		case $functionSeconds in
#			''|*[!0-9]*) functionSeconds=0 ;;
#		esac
		[[ "${functionSeconds}" -le "1" ]] && functionSeconds="0"
#		tmpT="${functionSeconds}${timeElapsed}"
		tmpT="${functionSeconds}.${functionMilliseconds}"
		logThis "Pass time '${tmpT}' to be processed." "X" "${FUNCNAME}"
		var=$(displaytime "${tmpT}")
		case "$4" in
			I|D)
				trackLevel="$4"
			;;
			*)
				trackLevel="T"
			;;
		esac
#		[[ "$4" == "D" ]] && trackLevel="$4" || trackLevel="T"
		[[ ! -z "${3}" ]] && logThis "[function runtime: $var]" "${trackLevel}" "$3" "$FUNCNAME" || logThis "...runtime: $var" "${trackLevel}"
	else
		logThis "Time tracking not possible, missing parameters." "D" "$3" "$FUNCNAME"
	fi
}

function removePushLock(){
	functionStartTime=$(/bin/date +'%s.%N')
	local maxAgeInSecs=$(( minNotifyIntervalInMinutes * 60 ))
	logThis "Push lock file ($trckErr) manipulation check. Notify interval (\$maxAgeInSecs) set to '$maxAgeInSecs'." "T" "$FUNCNAME"
	if [[ "$push" -ge "1" ]]; then
		logThis "Checking for push lock file ($trckErr)..." "T" "$FUNCNAME"
		if [ ! -f "$trckErr" ]; then
			mTime=0
			logThis "Push lock file ($trckErr) not found." "D" "$FUNCNAME"
		else
			logThis "Push lock file ($trckErr) found." "T" "$FUNCNAME"
			mTime=$(stat -c %Y "$trckErr")
			now=$(date +'%s')
			timeDiff=$(( now - mTime ))
			logThis "Times for '${trckErr}' mTime: $mTime, timeDiff: $timeDiff, epoch (now): '$now', $maxAgeInSecs" "T" "$FUNCNAME"
			waitMore=$(( maxAgeInSecs - timeDiff ))
			if [ "$timeDiff" -ge "$maxAgeInSecs" ]; then
				thisMuchTooOld=$(( timeDiff - maxAgeInSecs ))
				logThis "Removing $(displaytime $thisMuchTooOld) too old push lock file ($trckErr)..." "D" "$FUNCNAME"
				if [[ -w "$trckErr" ]]	; then
					logThis "Lock file check passed: file is writable by user." "T" "$FUNCNAME"
					if ${SH_RM} "$trckErr" &> /dev/null; then
						logThis "Push lock file ($trckErr) removed." "D" "$FUNCNAME"
					else
						logThis "Unable to remove push lock file ($trckErr)." "W" "$FUNCNAME"
					fi
				else
					logThis "Push lock not owned by user. Unable to remove, probably no push will be sent." "W"
				fi
			else
				logThis "Push lock file ($trckErr) found (origin time: $mTime, still $(displaytime ${waitMore}) until removal)." "D" "$FUNCNAME"
				#logThis "Push lock file age: $timeDiff sec(s). The lock will be removed when $waitThisLong sec(s) of age." "T" "$FUNCNAME"
				logThis "Push lock file ($trckErr) left untouched (not removed)." "T" "$FUNCNAME"
				#err "4" "$timeDiff"
			fi
		fi
		logThis "Push lock file ($trckErr) manipulation executed succesfully." "T" "$FUNCNAME"
	fi
	trackTime "$functionStartTime" "$(date +'%s.%N')" "$FUNCNAME"
}

ntfy() {
#telegramSend="/usr/local/bin/telegram-send"
telegramSend="/home/pi/bin/telegram-send.sh"
hdrFrmt="<b>"
hdrFrmtEnd="</b>"
functionStartTime=$(/bin/date +'%s.%N')
logThis "$FUNCNAME started." "T" "$FUNCNAME"
logThis "debug: $debug, push: $push." "T" "$FUNCNAME"
sndDt="$(date +'%d.%m.%y %H:%M.%S')"
msgFooter="\n[PID: $$]\nversion ${srcVersion}/${cmmVersion}"
if [ ! -z "${1+x}" ]; then
	# $1 message for Telegram
	# $2 title for Telegram
	# $3 target chat for Telegram (defaults to default if not found)
	telegramMsg="$1"
	logThis "Message received for delivery: '${msg}'." "D" "${FUNCNAME}"
	[ -z "${2+x}" ] || title="$2"
	[ -z "${3+x}" ] || telegramTarget="$3"
	[[ "${4}" -eq "1" ]] || reportStatus="1"

	###################################################################################################
	#
	#  Usage: ntfy "$msg" "$title"
	#
	#  Use PushBullet with care: you can easily flood a recipient with infinite number of messages if ntfy() is run from err() and
	#  script is scheduled to run every x mins or so... I use a coarse file name as identity placed in /lockdir/ for keeping track
	#  if a PushBullet message has already been sent. Make sure $trckErr is unique to the script but not too much (so it will still
	#  be recognized by the script).
	#
	###################################################################################################

	###################################################################################################
	#
        #  Not all ntfy's are created equal. If "push" is set 0 (default value) no PushBullet is launhced.
	#  The message is still logged, if localLogLevel=4+ is defined.
	#
	#  NOTE! Setting debug=1 will prevent messages from actually being pushed out by PushBullet regardless of
	#  'push' setting. This with logLevel of 3 (default) or lower will disrrgard the message all together.
	#
	logThis "Checking if push is enabled..." "T" "$FUNCNAME"
	if [ "$push" -gt "0" ]; then
		logThis "Push enabled." "D" "$FUNCNAME"
		removePushLock
		logThis "Checking push lock ($trckErr)..." "T" "$FUNCNAME"
#		if [[ ! -e "$trckErr" || -x "${telegramSend}" ]]; then
		if [[ ! -e "$trckErr" ]]; then
			logThis "Lock file ($trckErr) not found (or Telegram is used), creating lock file..." "D" "$FUNCNAME"
			[[ $(echo "1" > "$trckErr") ]] && err "1" "$trckErr" || logThis "Push lock file $trckErr created." "D" "$FUNCNAME"

			###################################################################################
			#
			#  The default errKills value (=1) takes care of killing the script before any
			#  PushBullet msg is sent but if you change the errKills value to 0
			#  this will no longer happen and you will flood error message
			#  because there is no trckErr file and one cannot be created!
			#
			#  This is needed for *$debug* as the default usage of PushBullet in script
			#  requires suppressing all output. This combined with *$debug* makes the
			#  SH_PUSHBULLET echo it's variables to /dev/null. So, if debug is enabled (>0)
			#  we'll logThis instead. Great success!
			#
			###################################################################################

			if [ "$debug" -eq "0" ]; then
				if [[ "${exitCode}" -eq "0" || "${pushErrors}" -gt "0" ]]; then
					logThis "exitCode: ${exitCode}, pushErrors: ${pushErrors}" "D" "$FUNCNAME"
					if [[ -x "$telegramSend" ]]; then
						logThis "${telegramSend} found." "T" "$FUNCNAME"
						if [ -z "${title+x}" ]; then
							logThis "Message to process is without title." "T" "$FUNCNAME"
							resT=$(${telegramSend} -m "${telegramMsg}${msgFooter}" -c "${telegramTarget}")
						else
							logThis "Message to process is with title ('$title')." "T" "$FUNCNAME"
							resT=$(${telegramSend} -t "${title}" -m "${telegramMsg}${msgFooter}" -c "${telegramTarget}")
						fi
					else
						[ -z ${title+x} ] && ${SH_PUSHBULLET} "${telegramMsg}" || ${SH_PUSHBULLET} "${telegramMsg}" "$title"
					fi
					logThis "Push message relayed..." "D" "$FUNCNAME"
				else
					if [[ -x "$telegramSend" ]]; then
						[ -z ${title+x} ] && resT=$(${telegramSend} -m "${telegramMsg}${msgFooter}" -c "${telegramTarget}") || resT=$(${telegramSend} -m "${telegramMsg}${msgFooter}" -t "$title" -c "${telegramTarget}")
					else
						[ -z ${title+x} ] && ${SH_PUSHBULLET} "${telegramMsg}" &> /dev/null || ${SH_PUSHBULLET} "${telegramMsg}" "$title" &> /dev/null
					fi
				fi
			fi
			logThis "Check $trckErr file for push lock manipulation..." "D" "$FUNCNAME"
		else
			if [[ "$errorCode" -eq "2" ]] && [[ "$lockCount" -eq "$b2bErrMax" ]]; then
				telegramTarget="script"
				logThis "Lock file found. ntfy() for lock file errors send if lockCount ("$lockCount") is equal to b2bErrMax ("$b2bErrMax")." "T" "$FUNCNAME"
				if [[ -x "$telegramSend" ]]; then
					[ -z ${title+x} ] && resT=$(${telegramSend} -m "${telegramMsg}${msgFooter}" -c "${telegramTarget}") || resT=$(${telegramSend} -m "${telegramMsg}${msgFooter}" -t "$title" -c "${telegramTarget}")
				else
					[ -z ${title+x} ] && ${SH_PUSHBULLET} "${telegramMsg}" &> /dev/null || ${SH_PUSHBULLET} "${telegramMsg}" "$title" &> /dev/null
				fi
			elif [[ "$lockCount" -gt "$b2bErrMax" ]]; then
				if rm -f "$lock"; then
					logThis "Lock file ('$lock') removed by rule: lockCount ("$lockCount") is greater than b2bErrMax ("$b2bErrMax")." "T" "$FUNCNAME"
				else
					logThis "Failed to remove lock file ('$lock'). Remove by rule: lockCount ("$lockCount") is greater than b2bErrMax ("$b2bErrMax")." "T" "$FUNCNAME"
				fi
			else
				logThis "Lock file found. Skipped push." "D" "$FUNCNAME"
			fi
			cloudLogAllowed=0
		fi
	else
		logThis "Push not enabled. Following is the push notification as it *would* be sent:" "T" "$FUNCNAME"
	fi
	# Redundant logging?
	[ -z ${title+x} ] || logThis "[PUSHBULLET] [TITLE]: $title" "T" "$FUNCNAME"
	[[ ! -z "${resT}" ]] && logThis "Telegram message response code: '${resT}'." "T"
	logThis "[PUSHBULLET] [ MSG ]: $1" "T" "$FUNCNAME"
	#
	###################################################################################################
fi
trackTime "$functionStartTime" "$(date +'%s.%N')" "$FUNCNAME"
[[ "${reportStatus}" -eq "1" ]] && echo "${resT}"
}

function valid_ip() {
	local stat=1
	if [[ ! -z "$1" ]]; then
		functionStartTime=$(/bin/date +'%s.%N')
		local ip=$(echo "$1"|xargs)
		logThis "IP to validate: '$ip'." "T" "${FUNCNAME}"

		if [[ $ip =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
			OIFS=$IFS
			IFS='.'
			ip=($ip)
			IFS=$OIFS
			logThis "Validating '${ip[0]}', '${ip[1]}', '${ip[2]}' and '${ip[3]}'." "T" "${FUNCNAME}"
			[[ ${ip[0]} -le 255 && ${ip[1]} -le 255 && ${ip[2]} -le 255 && ${ip[3]} -le 255 ]] && stat=0
			#stat=$?
			[[ "$stat" -eq "0" ]] && logThis "IP '$1' validated." "D" "${FUNCNAME}" || logThis "IP '$1' is not valid." "D" "${FUNCNAME}"
		else
			logThis "IP '$ip' is not valid." "D" "${FUNCNAME}"
			stat=1
		fi
		logThis "IP validation result: $stat" "T" "${FUNCNAME}"
		trackTime "$functionStartTime" "$(date +'%s.%N')" "$FUNCNAME"
	fi
	echo $stat
}

#################################
#
#  Use trap when locking the script from running multiple sessions
#  or at least running any real actions multiple times
#
#	tmpFile is not widely used. Creating file every time you run a script seems
#	absurd, so tmpFile is disabled. Enable per script as needed, not globally!
#	tmpFile=$( mktemp )
	lock="$lockdir/${myNameIs}.PID"
	logThis "Check for lock file: $lock..." "T"
	giveUpTime=999
#	logThis "$lock : $(( chkTime + giveUp )) ?? $(date +'%s')" "D"
	if [[ "$multiInstance" -ne "1" ]] && [[ ! "$multiInstance" == true ]]; then
		while [[ -f "$lock" ]] && [[ "$(( chkTime + giveUp ))" -gt "$(date +'%s')" ]]; do
#			[[ "$giveUpTime" -lt "1" ]] && exit 2
			giveUpTime=$(( chkTime + giveUp - $(date +'%s') ))
			logThis "Lock file found. Re-trying in ${chkSleeep} sec(s). Giving up in ${giveUpTime}..." "D"
			sleep "${chkSleeep}"

		done
		if [[ -f "$lock" ]]; then
			lockCount=$(head -1 "$lock")
			lockCount=$((lockCount+1))
#			echo "$lockCount" > "$lock"
			if [[ "$lockCount" -ge "$b2bErrMax" ]]; then
				rm -f "${lock}" || logThis "Unable to delete lockfile (${lock}). [${srcVersion}|${cmmVersion}|${errVersion}]" "W" "${FUNCNAME}"
				exit 1
			fi
			msgTxt="Lock file found [lockCount: $lockCount/$b2bErrMax]. Enable 'multiInstance' if multiple instances of script are needed."
			#msg="$myNameIs :: [ CRIT: 1/$logging] :: $msgTxt"
			#logger -s "$msg"
			logThis "$msgTxt" "C"
			#[[ "${pushErrors}" -gt "0" ]] && errLogging "D" "1" "$msgTxt"
			err 2 "$lock" "$msgTxt" "$myNameIs"
			#[[ "${pushErrors}" -gt "0" ]] && /usr/local/sbin/pushbullet.sh "$msg" "${HOSTNAME} :: CRITICAL ERROR!"
			exit 1
#		elif ! mkdir -p "$lock" 2>&1 > /dev/null; then
#		elif ! echo $$ > $lock; then
#		elif ! touch $lock; then
#		elif ! echo "$lockCount" > "$lock"; then
		elif ! echo "$$" > "$lock"; then
			msgTxt="Unable to create lock file."
#			msg="$myNameIs :: [ CRIT: 1/$logging] :: $msgTxt Exiting."
#      	  	        logger -s "$msg"
			logThis "$msgTxt" "C"
			[[ "${pushErrors}" -gt "0" ]] && errLogging "C" "0" "$msgTxt"
			[[ "${pushErrors}" -gt "0" ]] && /usr/local/sbin/pushbullet.sh "$msg" "${HOSTNAME} :: CRITICAL ERROR!"
			exit 1
		else
			logThis "Lock file ($lock) was not found. Lock file has been created." "T"
		fi
	else
		logThis "Multiple instances enabled. Continuing." "T"
	fi
	logThis "Lock file processed. It is safe to continue." "T"
#
exit_handler() {
	functionStartTime=$(/bin/date +'%s.%N')
	# 1. Make standard output be the original standard error
	#    (by using fd 3, which is a copy of original fd 2)
	# 2. Do the same with standard error
	# 3. Close fd 3.
	## Setting output to logfile only is not working. Disabled for now.
		#exec >&3 2>&3 3>&-
		[[ "${hideAllOutput}" -eq "1" ]] && exec >&3 2>&3 3>&-
		#cat "$logfile"
		if [[ ! -z "${errorCode}" ]]; then
			[[ -d "${HOME}/err/" ]] || mkdir "${HOME}/err/"
			[[ -d "${HOME}/err/" ]] && [[ "${errorCode}" -ge "1" ]] && cp -a "${logfile}" "${HOME}/err/err-${myNameIs}-${logdateForFile}-$$"
		fi
		if rm -f "$logfile"; then
			logThis "Removed temporary logfile $logfile." "T" "$FUNCNAME"
		else
			msg="Unable to remove logfile '$logfile'!"
        	        logThis "$msg" "C" "$FUNCNAME"
			ntfy "$msg" "CRITICAL ERROR!"
		fi
		if [ -e "$tmpFile" ]; then
			if rm -rf "$tmpFile"; then
				logThis "Removed temporary file $tmpFile." "D" "$FUNCNAME"
			else
				msg="Unable to remove temporary file $tmpFile!"
	        	        logThis "$msg" "C" "$FUNCNAME"
				ntfy "$msg" "CRITICAL ERROR!"
			fi
		fi
		if rm -f "$lock"; then
			logThis "Removed lock file $lock." "D" "$FUNCNAME"
			logThis "All those moments will be lost in time, like tears in rain." "T" "$FUNCNAME"

		else
			msg="$myNameIs :: [!CRIT: 1/$logging] :: Unable to remove lock file $lock!"
        	        logger -s "$msg"
			ntfy "$msg" "CRITICAL ERROR!"
		fi

		if [ -n "$(LC_ALL=C type -t runAtEXIT)" ] && [ "$(LC_ALL=C type -t runAtEXIT)" = function ]; then
			runAtEXIT
#		else
#			echo $function is NOT a function
		fi
		trackTime "$functionStartTime" "$(date +'%s.%N')" "$FUNCNAME"
		# the (almost) last log entry will be script's total runtime
		endTime=$(date +'%s.%N')
#		runTimeS=$(echo "scale=0;(${endTime} - ${strTime})/1"| bc -l)
		# >>>> convert runTimeS to humon tiem <<<<
		runTime=$(echo "scale=4;(${endTime} - ${strTime})/1"| bc -l)
#		runTimeS=$(echo $runTime|cut -d "." -f 1)
		[[ "$runTimeS" -lt "1" ]] && runTimeS=0
#		[[ "$runTimeS" -lt "1" ]] && zero="0" || zero=""
#		leftOvers=$(echo $runTime|cut -d "." -f 2)
		logThis "Script runtime variables: \$endTime: ${endTime}, \$strTime: ${strTime}, \$runTimeS: ${runTimeS} and \$leftOvers ${leftOvers}." "T" "$FUNCNAME"
#		humTiem=$(displaytime "$runTimeS" "$leftOvers")
		#logThis "Total runtime for $myNameIs was: $zero$runTime seconds." "I"
#		[[ "$runTimeS" -ge "60" ]] && msg="Total runtime for $myNameIs was: $humTiem (or in seconds: $zero$runTime)." || msg="Total runtime for $myNameIs was: $humTiem."
		msg="Total runtime for $myNameIs was: $runTime seconds (or $(displaytime "$runTime"))." 
		logThis "$msg $myNameIs v. $srcVersion stopped." "I"
		[[ "$extraLogLine" == "true" ]] && logThis " ---" "I"
#		logThis "$myNameIs v. $srcVersion stopped."

	}
	logfile=$( mktemp /lockdir/herabash-XXXXXXXX )
	# 1. Make fd 3 a copy of standard error (fd 2)
	# 2. Redirect original standard output to the logfile (appending)
	# 3. Redirect original standard error to the logfile (will also append)
## Setting output to logfile only is not working. Disabled for now.
#	exec 3>&2 >>"$logfile" 2>&1
	[[ "${hideAllOutput}" -eq "1" ]] && exec 3>&2 >>"$logfile" 2>&1
#
	# Use shell function for exit trap (for neatness)
	trap exit_handler EXIT
#
#	set -ex
#
#	trap 'rm -rf $lock' EXIT  # remove the lockdir on exit
#
#################################

#################################
#
#  Check if root privileges are required
#  and if they are exit if user is not root
#  NOTE! The notion is that ALL scripts must
#  be defined as NOT to require root privileges
#  or root privileges will be needed.
#
	if [ -z "$rootRequired" ]; then
		rootRequired=1
		logThis "variable \$rootRequired was unset. By default this means the script will require root user privileges. Variable \$rootRequired set to '$rootRequired'." "T"
	fi
	if [ "$rootRequired" = "1" ]; then
		if [ "$EUID" -ne "0" ]; then
			tmpMsg="This script must be run as root"
			${SH_ECHO} "$tmpMsg"
			${SH_LOGGER} "$myNameIs :: [CRITICAL: 1/$logging] :: $tmpMsg"
			exit 1
		fi
	else
		logThis "Script may be run as unprivileged user ($(${SH_WHOAMI}))." "T"
	fi
	logThis "Privilege check done." "T"
#
#
#################################

#################################
#
#  If you want errors to kill the script, use
#	errKills=1
#  else the exit code is just returned from function with
#	errKills=0
#  If nothing is defined, we use 1 (enabled)
	[ -z "$errKills" ] && errKills=1
	if [ "$errKills" -eq "1" ]; then
		logThis "Script will die on any error (\$errKills set to '$errKills')." "T"
	else
		logThis "Script will run regardless of any error (\$errKills set to '$errKills'). Errors will be logged." "T"
	fi
#
#
#################################

#################################
#
#  Debugging setup. Defines if more messages are displayed/pushed.
#  If nothing is defined, we use 3 (INFO)
#
	[ -z "$debug" ] && debug=0
	[ "$1" == "--test" ] && debug=1 && ${SH_ECHO} "Debugging mode enabled."
	if [ "$debug" -gt "0" ]; then
#		SH_LOGGER="/bin/echo"
		logThis "\$debug=$debug. PushBullet binary changed to $SH_PUSHBULLET." "T"
		SH_PUSHBULLET="/bin/echo"
	fi
#
#################################

#################################
#
#  Define if push notifications are sent or not
#
#  Here we define the default behaviour. If you set
#  	push=1
#  within your script, the script's config file
#  or from the command line (if the script takes
#  arguments) it will override this by design.
#
	[[ -z "$push" ]] && push=0
	logThis "Push set to '$push'." "T"
#
#  Define the minimum time between push notifications
#  The default is 120 mins so push notifications
#  would not clog up the system or recipient's device.
#
	[ -z "$minNotifyIntervalInMinutes" ] &&	minNotifyIntervalInMinutes=120
	#
	# !! NOTE !! (This will be a pain if it hits you while debugging...)
	# Between the hours set below the minNotifyIntervalInMinutes will be 4 times longer
	# ignoreNight=trueignoreNight=true overrides this
	#
	if [[ ! "$ignoreNight" ]]; then
		currenttime=$(date +%H:%M)
		if [[ "$currenttime" > "22:00" ]] || [[ "$currenttime" < "06:30" ]]; then
			minNotifyIntervalInMinutes=$(( minNotifyIntervalInMinutes * 4 ))
			logThis "Night time, minNotifyIntervalInMinutes (waitThisLong) is set to '$minNotifyIntervalInMinutes' or $(displaytime $(( minNotifyIntervalInMinutes * 60 )))." "D"
		fi
	fi
	#
	if [ "$push" -gt "0" ]; then
		logThis "Push notifications have a maximum set limit of 1 in every $minNotifyIntervalInMinutes mins(s) for this script. You can change this by setting \$minNotifyIntervalInMinutes to number of minutes script should wait between push notifications." "T"
	fi
#
#################################

#################################
#
#  Common variables setup
#
	logThis "Setting variables..." "T"
	myWholeNameIs="${0}"
	myArguments="${@}"
	title="$HOSTNAME [$myNameIs]"
	logThis "Setting variables [1/5]." "T"
#
# Remember to set the AWS_path and AWS_URL per script!
#
	#AWS_path="errors"
	#AWS_URL="${AWS_server}:${AWS_port}/${AWS_path}"
	#declare -g trckErr

	logThis "Setting variables [2/5]." "T"
	sleep=10
	#randomString=$(${SH_CAT} /dev/urandom | ${SH_TR} -dc 'a-zA-Z0-9' | ${SH_FOLD} -w 16 | ${SH_HEAD} -n 1)
	logThis "Setting variables [3/5]." "T"
	sTime=$(${SH_DATE} +'%s')
	logThis "Setting variables [4/5]." "T"
	OFFSET=$(date +%z)
	SIGN=${OFFSET:0:1}
	HOURS=${OFFSET:1:2}
	MINUTES=${OFFSET:3:2}
	EPOCH="$sTime"
	logThis "Setting variables [5/5]." "T"
#	sConvTime=$(( ${sTime} ${SIGN} ( ${HOURS} * 3600 + ${MINUTES} * 60 ) ))
	logdate=$(${SH_DATE} -d @"$sTime" +'%d.%m.%Y %H:%M:%S')
	logdateForFile=$(${SH_DATE} -d @"$sTime" +'%Y-%m-%d_%H-%M-%S')
	[[ -n "$waitThisLong" ]] && waitThisLong=$(( minNotifyIntervalInMinutes * 60 ))
	usageMessagePath="$myPathIs/etc/usg"
	usageMessageFile="$usageMessagePath/$myNameIs.usg"

	logThis "Variables have been set." "D"

	logThis "     [  script  variables  list  ]" "D"
	if [ ! -z ${myArguments+x} ]; then
		logThis "Given arguments               : $myArguments" "T"
	fi
	if [ ! -z ${title+x} ]; then
		logThis "Title for push notifications  : $title" "T"
	fi
	if [ ! -z ${trckErr+x} ]; then
		logThis "PushBullet lock file          : $trckErr" "T"
	fi
	if [ ! -z ${randomString+x} ]; then
		logThis "Random string                 : $randomString (\$randomString)" "T"
	fi
	if [ ! -z ${logfile+x} ]; then
		logThis "Temporary (log) file          : $logfile (\$logfile)" "D"
	fi
	if [ ! -z ${logdate+x} ]; then
		logThis "Script internal date and time : $logdate (\$logdate)" "D"
	fi
	if [ ! -z ${sTime+x} ]; then
		logThis "                     in Epoch : $sTime (\$sTime)" "T"
	fi
	if [ "$logging" -ge "5" ]; then
		logThis "Push                          : $push" "T"
		logThis "Debug                         : $debug" "T"
		errTorF=$( [[ "$errKills" == "1" ]] && echo "True" || echo "False")
		logThis "Error stops the script:       : $errTorF" "T"
		logThis "Sleep                         : $(displaytime $sleep)" "T"
	fi
	logThis "Uptime                        : ${uptimeInSecs} secs or $(displaytime "${uptimeInSecs}")" "D"
	if [ ! -z ${waitThisLong+x} ]; then
		logThis "Time to wait between pushes   : $(displaytime $waitThisLong) (or $waitThisLong second(s))" "T"
	fi
	logThis "     [ script variables list end ]" "D"

	[[ -r "${binPath}/${myNameIs}" ]] && srcVersion=$(head -10 "${binPath}/${myNameIs}"|grep "version"|tail -1|tr -d ' '|cut -d ':' -f 2)
	[[ -r "${binPath}/etc/common.cfg" ]] && cmmVersion=$(head -10 "${binPath}/etc/common.cfg"|grep "version"|tail -1|xargs|cut -d " " -f 3)
	[[ -r "${errConfFile}" ]] && errVersion=$(head -10 "${errConfFile}"|grep "version"|tail -1|xargs|cut -d " " -f 3)
#
#  Common variables setup end
#
#################################

#################################
#
#  Set some more [local] variables
#
#################################

#################################
#
#  Functions begin here
#

usage() {
	functionStartTime=$(/bin/date +'%s.%N')
	logThis "Checking for usage file..." "T" "$FUNCNAME"
	if [ -e "$usageMessageFile" ]; then
		usageMessage=$(<"$usageMessageFile")
		logThis "Usage file ($usageMessageFile) found." "D" "$FUNCNAME"
	else
		logThis "Usage file ($usageMessageFile) not found. This is not an error." "D" "$FUNCNAME"
	fi

	[ -z "$usageMessage" ] && usageMessage=' [No additional help provided. Sorry.]'
	usageMessage="Usage: $myNameIs $usageMessage\n"
	logThis "Printing usage message for user. This is not an error." "T" "$FUNCNAME"
	${SH_ECHO} -e "$usageMessage"
	logThis "Script end. This is not an error." "T" "$FUNCNAME"
	trackTime "$functionStartTime" "$(date +'%s.%N')" "$FUNCNAME"
	exit 1
}
curl2cloudCurling(){
	functionStartTime=$(/bin/date +'%s.%N')
	pad=$(printf '%0.1s' "."{1..60})
	padlength=15

#	for fillvar in AWS_path callPart cloudData; do
#		varMsg=$(printf '%s%*.*s%s\n' "$fillvar " 0 $((padlength - ${#fillvar})) "$pad" ": ${!fillvar}")
#		logThis "${varMsg}" "D" "$FUNCNAME"
#	done
#	mgc="MAGIC:" #curl -d \"$callPart\" -X POST \"${AWS_path}\" --write-out \"|\%{http_code}\""
#	varMsg=$(printf '%s%*.*s%s\n' "MAGIC: " 0 $((padlength - ${#mgc})) "$pad" ": ${!mgc}")
#	logThis "$varMsg" "T" "$FUNCNAME"
	curlResRAW=$(curl -d "$callPart" -X POST "${AWS_URL}" --write-out "|%{http_code}" --silent)
	curlRes=$(echo "$curlResRAW"|cut -d "|" -f "1")
	curlResStatus=$(echo "$curlResRAW"|cut -d "|" -f "2")

	for fillvar in AWS_path callPart cloudData curlRes curlResStatus; do
		varMsg=$(printf '%s%*.*s%s\n' "$fillvar " 0 $((padlength - ${#fillvar})) "$pad" ": ${!fillvar}")
		logThis "${varMsg}" "X" "$FUNCNAME"
	done

	logThis "MAGIC: curl -d \"$callPart\" -X POST \"${AWS_path}\" --write-out \"|\%{http_code}\"" "X" "$FUNCNAME"
	echo "$curlResRAW"
	trackTime "$functionStartTime" "$(date +'%s.%N')" "$FUNCNAME"
}

curl2cloud() {
	functionStartTime=$(/bin/date +'%s.%N')
#	AWS_server should be given as conf file item
#	AWS_port should be given as conf file item
#	AWS_path (or DB) must be given as $1
#	callPart must be given as $2
#	check for variables
	unset foundVars

	i=0
	for var in 1 2 AWS_server AWS_port; do
#		logThis "Checking \$$var..." "T" "$FUNCNAME"
		if [[ -z "${!var}" ]]; then
			logThis "Variable for \$${var} missing. Unable to continue." "X" "$FUNCNAME"
			foundVars="$foundVars\$$var: [ NOT FOUND! ]"
			# FIX! Break function and return error instead of exiting?
			return 2
		else
#			logThis "OK, good: \$${var} found." "T" "$FUNCNAME"
			[[ "$i" -gt "0" ]] && foundVars="${foundVars} | "
			foundVars="$foundVars\$$var: [ OK ]"
		fi
		(( i++ ))
	done
	logThis "Check for required variables: ${foundVars}." "X" "$FUNCNAME"
	AWS_path="$1"
	AWS_URL="${AWS_server}:${AWS_port}/${AWS_path}"
	callPart="$2"
	cloudData="${AWS_path};${callPart}"

	curlResRAW=$(curl2cloudCurling "${AWS_path}" "$callPart")
	curlRes=$(echo "$curlResRAW"|cut -d "|" -f "1")
	curlResStatus=$(echo "$curlResRAW"|cut -d "|" -f "2")

	# From here begins the redundancy for cloud uploads...

	# If data upload failed, re-try transmission (see https://stackoverflow.com/a/38905793 for curl options for this):
	# 1.   First with this data
	# 1.2. Re-try the upload (add data to csvFile if fail)
	# Next steps are taken in separate script(s)
	# 2.   ...and then with any other data still unsent
	# 2.1. Check for lines in csvFile and if found try to upload them as well
	# 2.2. If upload succeeds remove the line from csvFile
	# 3.   Try the next line in csvFile (if any left): loop 2.1 - 2.2 until all lines processed (succeeded or not)

	i=0
	retries=3

	while [[ "$curlResStatus" -ne "201" && "$i" -lt "$reTries" ]]; do
		# re-try data send
		(( i++ ))
		logThis "Re-trying (${i}/${reTries}) ${line} in ${sleep} sec(s)..." "T"
		sleep "$sleep"
#		curlResRAW=$(curl -d "$callPart" -X POST "${AWS_URL}" --write-out "|%{http_code}")
		curlResRAW=$(curl2cloudCurling "${AWS_URL}" "$callPart")
		curlRes=$(echo "$curlResRAW"|cut -d "|" -f "1")
		curlResStatus=$(echo "$curlResRAW"|cut -d "|" -f "2")
		logThis "DEBUG: '$curlResStatus' '$curlRes'." "T" "$FUNCNAME"
	done

	if [[ "$curlResStatus" -eq "201" ]]; then
		logThis "Uploaded '$AWS_path' status data to cloud with response: '$curlRes'." "D" "$FUNCNAME"
		#sed -i '/$cloudData/d' "$curlFile"
		ret=0
	else
		echo "$cloudData" >> "$curlFile"
		logThis "Cloud not reached (HTTP status: '$curlResStatus'). \"$cloudData\" automatically saved for retry." "I" "$FUNCNAME"
		ret=1
	fi
#echo "$curlRes"
echo "$ret"
#return $ret
trackTime "$functionStartTime" "$(date +'%s.%N')" "$FUNCNAME"
}

curl2cloudReDo() {
	functionStartTime=$(/bin/date +'%s.%N')
	unset vars

	for var in "$@"
	do
    		vars="${vars} ${var} "
	done
	res=(curl2cloud "$vars")
	trackTime "$functionStartTime" "$(date +'%s.%N')" "$FUNCNAME"
}

function convertTimeStampEpoch() {
	functionStartTime=$(/bin/date +'%s.%N')
	# human to epoch (eg. "Apr 28 07:50:01" to 1524916201)
	res=$(date -d "${1}" +"%s")
	${SH_ECHO} $res
	trackTime "$functionStartTime" "$(date +'%s.%N')" "$FUNCNAME"
}

function convertTimeStampHuman() {
	functionStartTime=$(/bin/date +'%s.%N')
	# epoch to human (eg. 1524916201 to "26.11.1970 07:50:01")
	res=$(date -d "@${1}" +"%d.%m.%Y %H:%M:%S")
	${SH_ECHO} $res
	trackTime "$functionStartTime" "$(date +'%s.%N')" "$FUNCNAME"
}

function convertTimeStampHumanZeroed() {
	functionStartTime=$(/bin/date +'%s.%N')
	# epoch to human (eg. 1524916201 to "26.11.1970 07:50:01")
	res=$(date -d "@${1}" +"%d.%m.%Y %H:%M")
	${SH_ECHO} $res
	trackTime "$functionStartTime" "$(date +'%s.%N')" "$FUNCNAME"
}

floatToInt() {
	functionStartTime=$(/bin/date +'%s.%N')
	${SH_PRINTF} "%.0f\n" "$1"
	trackTime "$functionStartTime" "$(date +'%s.%N')" "$FUNCNAME"
}

round() {
	functionStartTime=$(/bin/date +'%s.%N')
	[[ -z "$1" || -z "$2" ]] && err 30
	decimals=$(${SH_ECHO} ${2#-})
	[ "$decimals" -gt "4" ] && decimals=4
	res=$(${SH_AWK} 'BEGIN{printf "%.'"$decimals"'f\n", ('"$1"')}')
	${SH_ECHO} $res
	trackTime "$functionStartTime" "$(date +'%s.%N')" "$FUNCNAME"
}

show_versions() {
	functionStartTime=$(/bin/date +'%s.%N')
	/usr/local/sbin/sh.versions
	trackTime "$functionStartTime" "$(date +'%s.%N')" "$FUNCNAME"
}

versionHandler() {
	functionStartTime=$(/bin/date +'%s.%N')
	${SH_ECHO} "$@" | ${SH_AWK} -F. '{ printf("%d%03d%03d%03d\n", $1,$2,$3,$4); }';
	trackTime "$functionStartTime" "$(date +'%s.%N')" "$FUNCNAME"
}

transfer() {
	functionStartTime=$(/bin/date +'%s.%N')
	username=$3
	host=$4
	logThis "\$username: $username" "T" "$FUNCNAME"
	logThis "\$host: $host" "T" "$FUNCNAME"
	[ -z "$1" ] && err 10 "source"
	[ ! -e "$srcFile" ] && err 8 "$srcFile"
	tryCount=1
	tryLimit=10
	logThis "Copying:" "T" "$FUNCNAME"
	logThis "$SH_SCP -Bq $1 $3@$4:$2" "D" "$FUNCNAME"
	while ! ${SH_SCP} -Bq $1 $3@$4:$2; do
#	while [ "$?"  -ne "0" ]; do
		[ "$tryCount" -le "$tryLimit" ] || err 9 "$1"
		logThis "Something went wrong when copying file $1. Trying again ($tryCount/$tryLimit)" "D" "$FUNCNAME"
		${SH_SCP} -Br $1 $3@$4:$2
		(( tryCount ++ ))
		${SH_SLEEP} 1
	done
	logThis "File $1 copied successfully." "T" "$FUNCNAME"
	trackTime "$functionStartTime" "$(date +'%s.%N')" "$FUNCNAME"
}

transfer_debug() {
	functionStartTime=$(/bin/date +'%s.%N')
	username=$3
	host=$4
	[ -z "$1" ] && err 10 "source"
	[ ! -e "$srcFile" ] && err 8 "$srcFile"
	${SH_ECHO} "${SH_SCP} -Bq $1 $3@$4:$2"
	trackTime "$functionStartTime" "$(date +'%s.%N')" "$FUNCNAME"
}

checkDep() {
	functionStartTime=$(/bin/date +'%s.%N')
	unset errDep errDepOut fndDep fndDepOut
	for var in "$@"; do
#		set -a errDep fndDep
		logThis "Checking dependency for $var..." "T" "$FUNCNAME"
		if [ -e "$var" ]; then
#			logThis "Dependency '$var' found." "W" "$FUNCNAME"
			fndDep+=("$var")
		else
#			logThis "Dependency '$var' not found." "W" "$FUNCNAME"
			errKill=1
			errDep+=("$var")
			err 5 "$var"
		fi
		(( i++ ))
	done
	if [ ! -z "${fndDep[0]}" ]; then
		for dep in "${fndDep[@]}"; do
			fndDepOut+=" '$dep'"
		done
		logThis "Dependency check complete. Found:${fndDepOut}." "D" "$FUNCNAME"
	fi
	if [ ! -z "${errDep[0]}" ]; then
		for dep in "${errDep[@]}"; do
			errDepOut+=" '$dep'"
		done
		logThis "Not found: '$errDepOut'." "D" "$FUNCNAME"
	fi
	trackTime "$functionStartTime" "$(date +'%s.%N')" "$FUNCNAME"
}

elementIn() {
	functionStartTime=$(/bin/date +'%s.%N')
	#usage:
	#elementIn "a string" "${array[@]}"
	disco=0
	local e match="$1"
	shift
	logThis "Find if '$match' is in array..." "T" "$FUNCNAME"
	for e; do
		logThis "Find if '$match' ('$e') is in array..." "X" "$FUNCNAME"
		[[ "$e" == "$match" ]] && disco="1"
	done
	echo "${disco}"
	trackTime "$functionStartTime" "$(date +'%s.%N')" "$FUNCNAME"
}

function isInteger() {
	functionStartTime=$(/bin/date +'%s.%N')
	re='^[0-9]+$'
	if [[ "$1" =~ $re ]] ; then
		res=1
		logThis "'$1' is an integer." "D" "${FUNCNAME}"
	else
		res=0
		logThis "'$1' is not an integer." "D" "${FUNCNAME}"
	fi
	echo "$res"
	trackTime "$functionStartTime" "$(date +'%s.%N')" "${FUNCNAME}"
}

function isNumber() {
	functionStartTime=$(/bin/date +'%s.%N')
	re='^[+-]?[0-9]+([.][0-9]+)?$'
	if [[ "$1" =~ $re ]] ; then
		res=1
		logThis "'$1' is a number." "D" "${FUNCNAME}"
	else
		res=0
		logThis "'$1' is not a number." "D" "${FUNCNAME}"
	fi
	echo "$res"
	trackTime "$functionStartTime" "$(date +'%s.%N')" "${FUNCNAME}"
}

function showVars() {
	logThis "$1 :: ${1}" "T" "$FUNCNAME"
}

function processOrNot() {
	functionStartTime=$(/bin/date +'%s.%N')
	psSt=0
	[ -z "$1" ] && $(logThis "No process name given with argument" "W" "$FUNCNAME"; psSt=0)
	tmpMsg="Daemon $1 is "
	[ $(${SH_SYSTEMCTL} is-active "$1") ] && $(psSt=1; logThis "$tmpMsg active." "I" "$FUNCNAME") || $(psSt=0; logThis "$tmpMsg NOT active!" "W" "$FUNCNAME")
	trackTime "$functionStartTime" "$(date +'%s.%N')" "${FUNCNAME}"
	return $psSt
}

function condEcho() {
	functionStartTime=$(/bin/date +'%s.%N')
	logThis "Interactivity test called." "T" "$FUNCNAME"
	logThis "My \$-: "$- "D" "$FUNCNAME"
	if [[ -z "$PS1" ]]
	then
		logThis "This script was ran as interactive..." "T" "$FUNCNAME"
		${SH_ECHO} "$1"
	fi
	trackTime "$functionStartTime" "$(date +'%s.%N')" "${FUNCNAME}"
}

randoms() {
	functionStartTime=$(/bin/date +'%s.%N')
	# copyright: https://gist.github.com/earthgecko/3089509

	[[ -z "$1" ]] && strs=32 || strs=$1

	# bash generate random 32 character alphanumeric string (upper and lowercase) and
	NEW_UUID=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w $strs | head -n 1)

	# bash generate random 32 character alphanumeric string (lowercase only)
#	cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w $strs | head -n 1

	# Random numbers in a range, more randomly distributed than $RANDOM which is not
	# very random in terms of distribution of numbers.

	# bash generate random number between 0 and 9
#	cat /dev/urandom | tr -dc '0-9' | fold -w 256 | head -n 1 | head --bytes 1

	# bash generate random number between 0 and 99
#	NUMBER=$(cat /dev/urandom | tr -dc '0-9' | fold -w 256 | head -n 1 | sed -e 's/^0*//' | head --bytes 2)
#	if [ "$NUMBER" == "" ]; then
#		NUMBER=0
#	fi

	# bash generate random number between 0 and 999
#	NUMBER=$(cat /dev/urandom | tr -dc '0-9' | fold -w 256 | head -n 1 | sed -e 's/^0*//' | head --bytes 3)
#	if [ "$NUMBER" == "" ]; then
#		NUMBER=0
#	fi
	echo "$NEW_UUID"
	trackTime "$functionStartTime" "$(date +'%s.%N')" "${FUNCNAME}"
}

reload() {
	functionStartTime=$(/bin/date +'%s.%N')
	logThis "Reloading '$1'..." "D" "$FUNCNAME"
	if [[ -x "$1" ]]; then
		[[ -r "$1" ]] && $(. "$1")
	fi
	trackTime "$functionStartTime" "$(date +'%s.%N')" "$FUNCNAME"
}
uptimeCheck(){
	functionStartTime=$(/bin/date +'%s.%N')
	uptimeInSecs=$(cat /proc/uptime |cut -d " " -f 1 | cut -d "." -f 1|awk '{print int($1+0.5)}')
	echo $uptimeInSecs
	trackTime "$functionStartTime" "$(date +'%s.%N')" "${FUNCNAME}"
}
sleepLoop() {
	functionStartTime=$(/bin/date +'%s.%N')
	[[ -z "${1}" ]] && break || sleepInterval="${1}"
	if [[ "$(isInteger "${sleepInterval}")" -eq "1" ]]; then
		[[ ! -z "${2}" && "$(isInteger "${2}")" -eq "1" ]] && loopStart="${2}"
		if [[ "${sleepInterval}" -gt "0" && "${sleepInterval}" -lt "3600" ]]; then
			sleepPassed=0
			[[ -z "${loopStart}" ]] && loopStart=$(date +'%s')
			logThis "${FUNCNAME} started at $(convertTimeStampHuman "${loopStart}")." "D"
			while [[ "$(( sleepPassed + 1 ))" -le "$sleepInterval" ]]; do
				loopEnd=$(date +'%s')
				sleepPassed=$(( loopEnd - loopStart ))
				sleepTime=$(( loopEnd - sleepStart ))
				sleep 0.1
				logThis "${FUNCNAME} sleeping for ${sleepInterval} seconds.. ${sleepPassed} seconds passed, now at $(convertTimeStampHuman "${loopEnd}"). Still $(( sleepInterval - sleepPassed )) seconds to go..." "X"
			done
			logThis "${FUNCNAME} sleep done at $(convertTimeStampHuman "${loopEnd}"). ${sleepPassed} seconds passed." "D"
		fi
	fi
	trackTime "$functionStartTime" "$(date +'%s.%N')" "${FUNCNAME}"
}

getMQTToverride() {
	mqttOverride=$(/usr/bin/mosquitto_sub -h kanala -t ${mqttRelayOverrideTopic} -C 1)
	[[ $(isNumber "${mqttOverride}") -eq "1" ]] || mqttOverride=0
	logThis "'mqttOverride' is set to '${mqttOverride}'." "D" "${FUNCNAME}"
	return ${mqttOverride}
}

mtqq_override() {
	functionStartTime=$(/bin/date +'%s.%N')
	if [[ -z "$1" || "$(isNumber "$1" )" -ne "1" ]]; then
		/usr/bin/mosquitto_pub -h localhost -t ${mqttQueue}/override -m 0 --retain
		return 0
	fi
	/usr/bin/mosquitto_pub -h localhost -t ${mqttQueue}/override -m $1 --retain
	trackTime "${functionStartTime}" "$(date +'%s.%N')" "${FUNCNAME}"
	return $1
}

service_exists() {
	functionStartTime=$(/bin/date +'%s.%N')
	logThis "Parameters given '$1' and '$2'." "T" "${FUNCNAME}"
	local service="$1"
	if [[ -z "${service}" ]]; then
		returnCode=1
	else
		local serviceType="$2"
		[[ -z "${serviceType}" ]] && serviceType="service"
#	case ${service} in
#		data)
#			serviceType="mount"
#			;;
#		cockpit)
#			serviceType="socket"
#			;;
#		*)
#			serviceType="service"
#			;;
#	esac
#		if [[ $(systemctl list-units --all -t ${serviceType} --full --no-legend "${service}.${serviceType}" | cut -f1 -d' ') == "${service}.${serviceType}" ]]; then
#		if [[ $(systemctl list-units --all - ${serviceType} | grep "${service}.${serviceType}" | xargs | cut -f3 -d' ') == "${service}.${serviceType}" ]]; then
#			returnCode=0
#		else
#			returnCode=1
#		fi

		[[ -z "${allServiceFiles}" ]] && allServiceFiles=$(systemctl list-unit-files --type service|xargs)

		unset res
		res=$(echo ${allServiceFiles} | grep "${service}.${serviceType}")

		if [[ -z "${res}" ]]; then
			returnCode=1
		else
			returnCode=0
		fi

	fi
	trackTime "${functionStartTime}" "$(date +'%s.%N')" "${FUNCNAME}"
	return ${returnCode}
}

scriptEnd() {
	functionStartTime=$(/bin/date +'%s.%N')
	##################################################################
	#
	#  Destroy notify lock. Errors will exit program early
	#  so if the script survived here, all is well and notify
	#  lock can be removed if $waitThisLong seconds
	#  have passed. $waitThisLong is to stop error messages
	#  from flooding the recipient.
	#
	removePushLock
	if [[ ! -z ${msg+x} ]]; then
		[[ ! -z "${telegramChannel}" ]] && msgTargetChannel="${telegramChannel}" || msgTargetChannel="DEFAULT"
		logThis "Notifying leftovers (exitCode: ${exitCode}... [ ==> ntfy() \"\$msg\" ]" "I" "$FUNCNAME"
		if [[ "${exitCode}" -eq "0" || "${pushErrors}" -gt "0" ]]; then
			ntfy "$msg" "$title" "${telegramChannel}"
		fi
	else
		logThis "No message to push." "T" "$FUNCNAME"
	fi
	#
	##################################################################

	exit ${exitCode}
	trackTime "$functionStartTime" "$(date +'%s.%N')" "$FUNCNAME"
}
#
# Functions end.
#
#################################

#################################
#
#	post-functions
#
	checkDep /usr/bin/bc /usr/bin/curl

	uptimeInSecs=$(uptimeCheck)

	[[ -z "$AWS_server" && -z "$AWS_port" ]] && err 40 "AWS_server ['$AWS_server']|AWS_port ['$AWS_port']" || logThis "AWS: $AWS_server:$AWS_port" "T"

	logThis "Executive user: $(${SH_WHOAMI})" "T"
	logThis "PushBullet binary: ${SH_PUSHBULLET}" "T"
	trackTime "$commonStartTime" "$(date +'%s.%N')" "common.cfg"
	logThis "Read :: common configuration: done." "D"
#
#################################
