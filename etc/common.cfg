#!/bin/bash
myNameIs=${0##*/}
myPathIs=${0%/*}

#################################
#
#  version: 0.0.3.0040
#  date: 10.12.2018
#  mod': 10.02.2019
#  Copyright Tommi Nikkilae 2018
#  url: http://f8.oire.fi/blog (techy things)
#  url: http://f8.oire.fi/ (my photos)
#  email: f8@oire.fi
#  Released under GNU GPLv3
#
#################################

#################################
#
#  ext.conf
#
confErr() {

	RED='\033[0;31m'
	NC='\033[0m' # No Color

	case $1 in
		1)
			msg="Unable to create lock file. Check access rights on $lockdir/ and try again."
			outmsg="Unable to create lock file. Check the access rights on ${RED}$lockdir/${NC} and try again."
			;;
		5)
			msg="File $1 not found. This is fatal error. Die."
			;;
		*)
			msg="Unknown error occured. Die."
			;;
	esac
	[ -z ${outmsg+x} ] && echo -e "$msg" || echo "$outmsg"
	logger "$myNameIs :: [CRITICAL: 1/$logging] :: $msg"
	exit $1
}
	[ -z "$logging" ] && logging=3
	[ -z "$debug" ] && debug=0
	if [ "$debug" -gt "0" ]; then
		debugInfo="$myNameIs :: [TRACE: 5/$logging] :: I am $myPathIs/$myNameIs"
		[ "$logging" -ge "5" ] && logger "$debugInfo logging: ENABLED" #|| logger "$debugInfo [logging: DISABLED]"
	fi
#
#  see if /lockdir/ is writable. if not, die
#
	lockdir="/lockdir"
	[ ! -w "$lockdir" ] && confErr 1
#
#  Our default incl. path is /your/script's/path/ + etc/|sbin/|[etc.]
#  See if the configuration files are found there. If not, use the global default /usr/local/ + etc/|sbin/
#
	if [ -f "$myPathIs/etc/shellcommands.cfg" ]; then
		if [ -f "$myPathIs/etc/errors.cfg" ]; then
			incPath="$myPathIs"
		else
			incPath="/usr/local"
		fi
	else
		incPath="/usr/local"
	fi
#
#  shell commands
#
	confFile="$incPath/etc/shellcommands.cfg"
	if . "$confFile"; then
		 [ "$logging" -ge "5" ] && logger "$myNameIs :: [TRACE: 5/$logging] :: read shell commands from $confFile"
	else
		confErr 5 "$confFile"
	fi
#	[ -f "$confFile" ] && . "$confFile" || confErr 5 "$confFile"
#
#  err()
#
	confFile="$incPath/etc/errors.cfg"
	if . "$confFile"; then
		[ "$logging" -ge "5" ] && logger "$myNameIs :: [TRACE: 5/$logging] :: read error handling from $confFile"
	else
		confErr 5 "$confFile"
	fi
#	[ -f "$confFile" ] && . "$confFile" || confErr 5 "$confFile"
#
#
#  read/load configuration option specific to this script (if found)
	confFile="$incPath/etc/conf/$myNameIs.conf"
	if [ -f "$confFile" ]; then
		if . "$confFile"; then
			[ "$logging" -ge "5" ] && logger "$myNameIs :: [TRACE: 5/$logging] :: Configuration file $confFile read."
		else
			[ "$logging" -ge "2" ] && logger "$myNameIs :: [WARN!: 2/$logging] :: read $confFile FAILED!"
		fi
	else
		[ "$logging" -ge "4" ] && logger "$myNameIs :: [DEBUG: 4/$logging] :: Configuration file $confFile not found. This is not an error."
	fi
#
#  ext. conf end
#
#################################

#################################
#
#  Use trap when locking the script from running multiple sessions
#  or at least running any real actions multiple times
	tmpFile=$( mktemp )
	lock="$lockdir/."$myNameIs".lock"
	[ "$logging" -ge "5" ] && logger "$myNameIs :: [TRACE: 5/$logging] :: Check for lockfile: $lock..."
	if ! ${SH_MKDIR} "$lock" &> /dev/null; then
		if [ "$force" = "1" ]; then
			# attempt to remove and check again
			[ "$logging" -ge "5" ] && logger "$myNameIs :: [TRACE: 5/$logging] :: Lock file found, attempting to remove it by force..."
			if ! ${SH_RMDIR} "$lock" &> /dev/null; then
				${SH_LOGGER} "$myNameIs :: [CRITICAL: 1/$logging] :: Script already running. Exiting."
				exit 1
			elif ! ${SH_MKDIR} "$lock" &> /dev/null; then
				${SH_LOGGER} "$myNameIs :: [CRITICAL: 1/$logging] :: Unable to create lock file. Exiting."
				exit 1
			else
				[ "$logging" -ge "4" ] && ${SH_LOGGER} "$myNameIs :: [DEBUG: 4/$logging] :: Previous lock file forcibly removed and new lock file created. Script is allowed to continue."
			fi
		fi
	else
		[ "$logging" -ge "5" ] && logger "$myNameIs :: [TRACE: 5/$logging] :: Lockfile ($lock) was not found. Lockfile has been created."
	fi
#	chmod 700 "$lock"
#	if ! ${SH_CHOWN} 777 "$lock" &> /dev/null; then
#		${SH_LOGGER} "$myNameIs :: Unable to change access rights to '$lock'. Exiting."
#	fi
	[ "$logging" -ge "5" ] && logger "$myNameIs :: [TRACE: 5/$logging] :: Lockfile prosessed. It is safe to continue."
#
	exit_handler () {
	# 1. Make standard output be the original standard error
	#    (by using fd 3, which is a copy of original fd 2)
	# 2. Do the same with standard error
	# 3. Close fd 3.
		exec >&3 2>&3 3>&-
		cat "$logfile"
		if rm -f "$logfile"; then
			[ "$logging" -ge "5" ] && logger "$myNameIs :: [TRACE: 5/$logging] :: $FUNCNAME() :: Removed temporary logfile $logfile."
		else
			logger "$myNameIs :: [!CRIT: 1/$logging] :: $FUNCNAME() :: Unable to remove logfile '$logfile'!"
		fi
		if [ -e "$tmpFile" ]; then
			if rm -rf "$tmpFile"; then
				[ "$logging" -ge "4" ] && logger "$myNameIs :: [DEBUG: 4/$logging] :: $FUNCNAME() :: Removed temporary file $tmpFile."
			else
				logger "$myNameIs :: [!CRIT: 1/$logging] :: Unable to remove temporary file $tmpFile!"
			fi
		fi
		if rm -rf "$lock"; then
			[ "$logging" -ge "4" ] && logger "$myNameIs :: [DEBUG: 4/$logging] :: $FUNCNAME() :: Removed lock file $lock."
			[ "$logging" -ge "5" ] && logger "$myNameIs :: [TRACE: 5/$logging] :: $FUNCNAME() :: All those moments will be lost in time, like tears in rain."

		else
			logger "$myNameIs :: [!CRIT: 1/$logging] :: Unable to remove lock file $lock!" 
		fi
	}
#
	logfile=$( mktemp )
#
	# 1. Make fd 3 a copy of standard error (fd 2)
	# 2. Redirect original standard output to the logfile (appending)
	# 3. Redirect original standard error to the logfile (will also append)
	exec 3>&2 >>"$logfile" 2>&1
#
	# Use shell function for exit trap (for neatness)
	trap exit_handler EXIT
#
#	set -ex
#
#	trap 'rm -rf $lock' EXIT  # remove the lockdir on exit
#
#################################

#################################
#
#  Check if root privileges are required
#  and if they are exit if user is not root
#  NOTE! The notion is that ALL scripts must
#  be defined as NOT to require root privileges
#  or root privileges will be needed.
#
	if [ -z "$rootRequired" ]; then
		rootRequired=1
		[ "$logging" -ge "5" ] && ${SH_LOGGER} "$myNameIs :: [TRACE: 5/$logging] :: variable \$rootRequired was unset. By default this means the script will require root user priviledges. Variable \$rootRequired set to '$rootRequired'."
	fi
	if [ "$rootRequired" = "1" ]; then
		if [ "$EUID" -ne "0" ]; then
			tmpMsg="This script must be run as root"
			${SH_ECHO} "$tmpMsg"
			${SH_LOGGER} "$myNameIs :: [CRITICAL: 1/$logging] :: $tmpMsg"
			exit 1
		fi
	else
		[ "$logging" -ge "5" ] && ${SH_LOGGER} "$myNameIs :: [TRACE: 5/$logging] :: Script may be run as unpriviliedged user ($(${SH_WHOAMI}))."
	fi
	[ "$logging" -ge "5" ] && ${SH_LOGGER} "$myNameIs :: [TRACE: 5/$logging] :: Priviledge check done."
#
#
#################################

#################################
#
#  If you want errors to kill the script, use
#	errKills=1
#  else the exit code is just returned from function with
#	errKills=0
#  If nothing is defined, we use 1 (enabled)
	[ -z "$errKills" ] && errKills=1
	if [ "$errKills" -eq "1" ]; then
		[ "$logging" -ge "5" ] && ${SH_LOGGER} "$myNameIs :: [TRACE: 5/$logging] :: Script will die on any error (\$errKills set to '$errKills')."
	else
		[ "$logging" -ge "5" ] && ${SH_LOGGER} "$myNameIs :: [TRACE: 5/$logging] :: Script will run regardless of any error (\$errKills set to '$errKills'). Errors will be logged."
	fi
#
#
#################################

#################################
#
#  Debugging setup. Defines if more messages are displayed/pushed.
#  If nothing is defined, we use 3 (INFO)
#
	[ -z "$debug" ] && debug=0
	[ "$1" == "--test" ] && debug=1 && ${SH_ECHO} "Debugging mode enabled."
	if [ "$debug" -gt "0" ]; then
#		SH_LOGGER="/bin/echo"
		[ "$logging" -ge "5" ] && ${SH_LOGGER} "$myNameIs :: [TRACE: 5/$logging] :: \$debug=$debug. PushBullet binary changed to $SH_PUSHBULLET."
		SH_PUSHBULLET="/bin/echo"
	fi
#
#################################

#################################
#
#  Define if push notifications are sent or not
#
#  Here we define the default behaviour. If you set
#  	push=1
#  within your script, the script's config file
#  or from the command line (if the script takes
#  arguments) it will override this by design.
#
	push=0
	[ "$logging" -ge "5" ] && ${SH_LOGGER} "$myNameIs :: [TRACE: 5/$logging] :: Push set to '$push'."
#
#  Define the minimum time between push notifications
#  The default is 15 mins so push notifications
#  would not colg up the system or recipient's device.
#
	[ -z "$minNotifyIntervalInMinutes" ] &&	minNotifyIntervalInMinutes=15
	if [ "$push" -gt "0" ]; then
		[ "$logging" -ge "5" ] && ${SH_LOGGER} "$myNameIs :: [TRACE: 5/$logging] :: Push notifications have a maximum set limit of 1 in every $minNotifyIntervalInMinutes mins(s) for this script. You can change this by setting \$minNotifyIntervalInMinutes to number of minutes script should wait between push notifications."
	fi
#
#################################

#################################
#
#  Common variables setup
#
	[ "$logging" -ge "5" ] && ${SH_LOGGER} "$myNameIs :: [TRACE: 5/$logging] :: Setting variables..."
	myWholeNameIs="${0}"
	myArguments="${@}"
	title="$HOSTNAME [$myNameIs]"
	[ "$logging" -ge "5" ] && ${SH_LOGGER} "$myNameIs :: [TRACE: 5/$logging] :: Setting variables [1/4]."
	#declare -g trckErr
	[ "$logging" -ge "5" ] && ${SH_LOGGER} "$myNameIs :: [TRACE: 5/$logging] :: Setting variables [2/4]."
	trckErr="/lockdir/.$myNameIs.err.lock"
	sleep=10
	#randomString=$(${SH_CAT} /dev/urandom | ${SH_TR} -dc 'a-zA-Z0-9' | ${SH_FOLD} -w 16 | ${SH_HEAD} -n 1)
	[ "$logging" -ge "5" ] && ${SH_LOGGER} "$myNameIs :: [TRACE: 5/$logging] :: Setting variables [3/4]."
	sTime=$(${SH_DATE} +'%s')
	OFFSET=$(date +%z)
	SIGN=${OFFSET:0:1}
	HOURS=${OFFSET:1:2}
	MINUTES=${OFFSET:3:2}
	EPOCH="$sTime"
	[ "$logging" -ge "5" ] && ${SH_LOGGER} "$myNameIs :: [TRACE: 5/$logging] :: Setting variables [4/4]."
#	sConvTime=$(( ${sTime} ${SIGN} ( ${HOURS} * 3600 + ${MINUTES} * 60 ) ))
	logdate=$(${SH_DATE} -d @"$sTime" +'%d.%m.%Y %H:%M:%S')
	waitThisLong=$(( minNotifyIntervalInMinutes * 60 ))
	usageMessagePath="$myPathIs/etc/usg"
	usageMessageFile=$usageMessagePath"/"$myNameIs".usg"

	[ "$logging" -ge "5" ] && ${SH_LOGGER} "$myNameIs :: [TRACE: 5/$logging] :: Variables have been set."

#	[ "$logging" -ge "5" ] && ${SH_LOGGER} "$myNameIs :: [TRACE: 5/$logging]"
	[ "$logging" -ge "5" ] && ${SH_LOGGER} "$myNameIs :: [TRACE: 5/$logging] ::      [  script  variables  list  ]"
	if [ ! -z ${myArguments+x} ]; then
		 [ "$logging" -ge "5" ] && ${SH_LOGGER} "$myNameIs :: [TRACE: 5/$logging] :: Given arguments               : $myArguments"
	fi
	if [ ! -z ${title+x} ]; then
		[ "$logging" -ge "5" ] && ${SH_LOGGER} "$myNameIs :: [TRACE: 5/$logging] :: Title for push notifications  : $title"
	fi
	if [ ! -z ${trckErr+x} ]; then
		[ "$logging" -ge "5" ] && ${SH_LOGGER} "$myNameIs :: [TRACE: 5/$logging] :: PushBullet lock file          : $trckErr"
	fi
	if [ ! -z ${randomString+x} ]; then
		[ "$logging" -ge "5" ] && ${SH_LOGGER} "$myNameIs :: [TRACE: 5/$logging] :: Random string                 : $randomString (\$randomString)"
	fi
	if [ ! -z ${tmpFile+x} ]; then
		[ "$logging" -ge "5" ] && ${SH_LOGGER} "$myNameIs :: [TRACE: 5/$logging] :: Temporary file                : $tmpFile (\$tmpFile)"
	fi
	if [ ! -z ${logdate+x} ]; then
		 [ "$logging" -ge "5" ] && ${SH_LOGGER} "$myNameIs :: [TRACE: 5/$logging] :: Script internal date and time : $logdate"
	fi
	if [ ! -z ${sTime+x} ]; then
		[ "$logging" -ge "5" ] && ${SH_LOGGER} "$myNameIs :: [TRACE: 5/$logging] ::                      in Epoch : $sTime"
	fi
	if [ ! -z ${waitThisLong+x} ]; then
		[ "$logging" -ge "5" ] && ${SH_LOGGER} "$myNameIs :: [TRACE: 5/$logging] :: Time to wait between pushes   : $minNotifyIntervalInMinutes minutes(s) (or $waitThisLong second(s))"
	fi
	[ "$logging" -ge "5" ] && ${SH_LOGGER} "$myNameIs :: [TRACE: 5/$logging] ::      [ script variables list end ]"
#	[ "$logging" -ge "5" ] && ${SH_LOGGER} "$myNameIs :: [TRACE: 5/$logging]"
#
#
#  Common variables setup end
#
#################################

#################################
#
#  Set some more [local] variables
#
#################################

#################################
#
#  Functions begin here
#
logThis() {
#	We use different log levels, mainly:
#		1 or [C|c]ritical
#		2 or [W|w]arning
#		3 or [I|i]nfo (as default, if no log level is defined)
#		4 or [D|d]ebug
#		5 or [T|t]race
#
#	When logging, use logLevels as:
#
#	logThis "Your message." "logLevel" "$FUNCNAME"
#	The "$FUNCNAME" is optional. It provides users with more information by logging the name of function
#	calling for logThis().
#	eg.
#	logThis "Something happened. Call anybody for help even at 2AM!" "C" "$FUNCNAME"
#	logThis "Device unavailable. Skipping." "w" "$FUNCNAME"
#	logThis "Event completed successfully." "I"
#	logThis "Configuration file not found. Using defaults." "d" "$FUNCNAME"
#	logThis "Parsing variables, var #3 has value..." "t"
#
#	!NOTE! If loggin is set to '0', nothing is logged with
#	the exception of CRITICAL or [C|c] which is ALWAYS logged.
#
#	Configuration option 'logging' is used to define messages of logLevel or lower to actually write to syslog.
#	At logging=1 we will log only messages with Critical logLevel, at logging=3 we will log messages of
#	logLevel Critical, Warning and Info, etc.
#	Default logging 3.
#
	forceLogging=0
	case $2 in
		"C"|"c"|1 ) #critical
			logInfo="!CRIT"
			logLevel=1
			forceLogging=1
			;;
		"W"|"w"|2 ) #warn
			logInfo="WARN!"
			logLevel=2
			;;
		"I"|"i"|3 ) #info
			logInfo=" INFO"
			logLevel=3
			;;
		"D"|"d"|4 ) #debug
			logInfo="DEBUG"
			logLevel=4
			;;
		"T"|"t"|5 ) #trace
			logInfo="TRACE"
			logLevel=5
			;;
		* ) #info
			logInfo=" INFO"
			logLevel=3
			;;
	esac

	if [ "$logging" -gt "0" ]; then
		if [ "$logging" -ge "$logLevel" ]; then
			lS=" :: "
			logMsg="$myNameIs$lS"
			logMsg=$logMsg"[$logInfo: $logLevel/$logging]$lS"
			[ -z ${3+x} ] || logMsg=$logMsg"$3()$lS"
			logMsg=$logMsg"$1"
			${SH_LOGGER} "$logMsg" >/dev/null 2>&1
		fi
	elif [ "$forceLogging" -eq "1" ]; then  #Always log CRITICAL level messages
			lS=" :: "
			logMsg="$myNameIs$lS"
			logMsg=$logMsg"[$logInfo: $logLevel/$logging]$lS"
			[ -z ${3+x} ] || logMsg=$logMsg"$3()$lS"
			logMsg=$logMsg"$1"
			${SH_LOGGER} "$logMsg" >/dev/null 2>&1
#			${SH_LOGGER} "$myNameIs :: [!CRIT] :: $1"
	fi
}

usage() {
	logThis "Checking for usage file..." "T" "$FUNCNAME"
	if [ -e "$usageMessageFile" ]; then
		usageMessage=$(<$usageMessageFile)
		logThis "Usage file ($usageMessageFile) found." "T" "$FUNCNAME"
	else
		logThis "Usage file ($usageMessageFile) not found. This is not an error." "T" "$FUNCNAME"
	fi

	[ -z "$usageMessage" ] && usageMessage=' [No additional help provided. Sorry.]'
	usageMessage="Usage: "$myNameIs" "$usageMessage"\n"
	logThis "Printing usage message for user. This is not an error." "T" "$FUNCNAME"
	${SH_ECHO} -e "$usageMessage"
	logThis "Script end. This is not an error." "T" "$FUNCNAME"
	exit 1
}

ntfy() {
if [ ! -z ${1+x} ]; then
	[ -z ${2+x} ] || title=$2

	###################################################################################################
	#
	#  Usage: ntfy "$msg" "$title"
	#
	#  Use PushBullet with care: you can easily flood a recipient with infinite number of messages if ntfy() is run from err() and
	#  script is scheduled to run every x mins or so... I use a coarse file name as identity placed in /lockdir/ for keeping track
	#  if a PushBullet message has already been sent. Make sure $trckErr is unique to the script but not too much (so it will still
	#  be recognized by the script).
	#
	###################################################################################################

	###################################################################################################
	#
        #  Not all ntfy's are created equal. If "push" is set 0 (default value) no PushBullet is launhced.
	#  The message is still logged, if logLevel=4+ is defined.
	#
	#  NOTE! Setting debug=1 will prevent messages from actually being pushed out by PushBullet regardless of
	#  'push' setting. This with logLevel of 3 (default) or lower will disrrgard the message all together.
	#
	logThis "Checking if push is enabled..." "T" "$FUNCNAME"
	if [ "$push" -gt "0" ]; then
		logThis "Push enabled." "T" "$FUNCNAME"
		logThis "Checking for lock file for push ($trckErr)..." "T" "$FUNCNAME"
		if [ ! -e "$trckErr" ]; then
			logThis "Lock file ($trckErr) not found, creating..." "T" "$FUNCNAME"
			[ $(${SH_TOUCH} $trckErr & > /dev/null) ] && err "1" "$trckErr" || logThis "Push lock file $trckErr created." "D" "$FUNCNAME"

			###################################################################################
			#
			#  The default errKills value (=1) takes care of killing the script before any
			#  PushBullet msg is sent but if you change the errKills value to 0
			#  this will no longer happen and you will flood error message
			#  because there is no trckErr file and one cannot be created!
			#
			#  This is needed for *$debug* as the default usage of PushBullet in script
			#  requires suppressing all output. This combined with *$debug* makes the
			#  SH_PUSHBULLET echo it's variables to /dev/null. So, if debug is enabled (>0)
			#  we'll logThis instead. Great success!
			#
			###################################################################################

			if [ "$debug" -eq "0" ]; then
				[ -z ${title+x} ] && ${SH_PUSHBULLET} "$1" &> /dev/null || ${SH_PUSHBULLET} "$1" "$title" &> /dev/null
				logThis "There should be a PushBullet message waiting for you..." "D" "$FUNCNAME"
			fi
			logThis "Check $trckErr for PushBullet messages..." "D" "$FUNCNAME"
		else
			logThis "Lock file found. Skipped push." "T" "$FUNCNAME"
		fi
	else
		logThis "Push not enabled. Following is the push notification as it *would* be sent:" "D" "$FUNCNAME"
	fi
	#
	[ -z ${title+x} ] || logThis "[PUSHBULLET] [TITLE]: $title" "D" "$FUNCNAME"
	logThis "[PUSHBULLET] [ MSG ]: $1" "D" "$FUNCNAME"
	#
	###################################################################################################
fi
}

getDHTread() {
	logThis "getDHTread() here, hello!" "T" "$FUNCNAME"
        case $1 in
                hum )
			column=3
			;;
                temp )
			column=2
			;;
		* )
			err
			;;
	esac
# This is here until we get our /usr/local/sbin/DHTXXD to function properly...
	SH_DHT="/usr/local/sbin/DHTXXD-exec"
#	SH_DHT="/usr/local/sbin/DHTXXD"

#
        dht22LockFile="/lockdir/dht22LockFile"
#
# Check for our lock file;
# If exists, wait: another script is accessing DHT22
#
	i=0
	maxWaitIters=10
#
	while [ -f "$dht22LockFile" ]; do
		logThis "DHT22 busy, waiting ($i/$maxWaitIters)..." "D" "$FUNCNAME"
		${SH_SLEEP} $sleep;
		(( i++ ))
		if [ "$i" -eq "$maxWaitIters" ]; then
			err 19 "$myNameIs, $i tries"
			break
		fi
	done
#
# Create lock file to prevent other scripts from
# accessing DHT22 while we poll it
#
	[ $(${SH_TOUCH} $dht22LockFile & > /dev/null) ] && err "1" "$dht22LockFile" || logThis "Lock file $dht22LockFile created." "D" "$FUNCNAME"

	DHT22raw=$(${SH_DHT})
	DHT22status=$(${SH_ECHO} "$DHT22raw"|${SH_CUT} -d " " -f 1)
	DHT22res=$(${SH_ECHO} "$DHT22raw"|${SH_CUT} -d " " -f $(${SH_ECHO} "$column"))

	logThis "raw: $DHT22raw" "T" "$FUNCNAME"
	#logThis "status: $DHT22raw" "T" "$FUNCNAME"
	#logThis "res: $DHT22raw" "T" "$FUNCNAME"

	i=1
	sleep=2
	maxIters=5


	while [ "$DHT22status" -gt "0" ]; do
		logThis "DHT22 read iteration $i/$maxIters" "T" "$FUNCNAME"
		if [ "$i" -ge "$maxIters" ]; then
			# Remove DHT22 lock for others to read the DHT22...
			[ $(${SH_RM} -f $dht22LockFile & > /dev/null) ] && err "2" "$dht22LockFile" || logThis "Lock file $dht22LockFile removed." "D" "$FUNCNAME"

			iterSecs=$(echo "scale=0; ($i*$sleep)/1"|bc -l)
			logThis "Read error from DHT22. Error count: $i of $maxIters [$iterSecs sec(s)]). Read: (\$in) '$DHT22res', (\$DHT22status) '$DHT22status'." "C" "$FUNCNAME"
			err 19 "stat: $DHT22status, read: $DHT22res"
			break
			exit 1
		fi

##		in=$(${SH_DHT}|${SH_CUT} -d " " -f 2)
		# No need for lock file here as we haven't removed the one we created earlier...
		# Just make sure we are not reading it too fast
		${SH_SLEEP} $sleep;

		DHT22raw=$(${SH_DHT})
		DHT22res=$(${SH_ECHO} "$DHT22raw"|${SH_CUT} -d " " -f $(${SH_ECHO} "$column"))
		DHT22status=$(${SH_ECHO} "$DHT22raw"|${SH_CUT} -d " " -f 1)
		[ "$DHT22status" -eq "0" ] && logThis "Read error from DHT22 recovered; stat: $DHT22status, read: $DHT22res" "D" "$FUNCNAME"
		(( i++ ))
	done
	title="DHT22"
	z=$(${SH_ECHO} "scale=1;$(${SH_ECHO} $DHT22res)/1" | bc -l)
	${SH_SLEEP} $sleep;
	[ $(${SH_RM} -f $dht22LockFile & > /dev/null) ] && err "2" "$dht22LockFile" || logThis "Lock file $dht22LockFile removed." "D" "$FUNCNAME"
	${SH_ECHO} "$z"
}

function convertTimeStampEpoch() {
	# human to epoch (eg. "Apr 28 07:50:01" to 1524916201)
	res=$(date -d "${1}" +"%s")
	${SH_ECHO} $res
}

function convertTimeStampHuman() {
	# epoch to human (eg. 1524916201 to "26.11.1970 07:50:01")
	res=$(date -d "@${1}" +"%d.%m.%Y %H:%M:%S")
	${SH_ECHO} $res
}

function convertTimeStampHumanZeroed() {
	# epoch to human (eg. 1524916201 to "26.11.1970 07:50:01")
	res=$(date -d "@${1}" +"%d.%m.%Y %H:%M")
	${SH_ECHO} $res
}

floatToInt() {
	${SH_PRINTF} "%.0f\n" "$1"
}

round() {
	[[ -z "$1" || -z "$2" ]] && err 30
	decimals=$(${SH_ECHO} ${2#-})
	[ "$decimals" -gt "4" ] && decimals=4
	res=$(${SH_AWK} 'BEGIN{printf "%.'"$decimals"'f\n", ('"$1"')}')
	${SH_ECHO} $res
}

show_versions() {
	/usr/local/sbin/sh.versions
}

versionHandler() {
	${SH_ECHO} "$@" | ${SH_AWK} -F. '{ printf("%d%03d%03d%03d\n", $1,$2,$3,$4); }';
}

transfer() {
	username=$3
	host=$4
	logThis "\$username: $username" "T" "$FUNCNAME"
	logThis "\$host: $host" "T" "$FUNCNAME"
	[ -z "$1" ] && err 10 "source"
	[ ! -e "$srcFile" ] && err 8 "$srcFile"
	tryCount=1
	tryLimit=10
	logThis "Copying:" "T" "$FUNCNAME"
	logThis "$SH_SCP -Bq $1 $3@$4:$2" "T" "$FUNCNAME"
	${SH_SCP} -Bq $1 $3@$4:$2
	while [ "$?"  -ne "0" ]; do
		[ "$tryCount" -lt "$tryLimit" ] || err 9 "$1"
		logThis "Something went wrong when copying file $1. Trying again ($tryCount/$tryLimit)" "T" "$FUNCNAME"
		${SH_SCP} -Br $1 $3@$4:$2
		(( tryCount +1 ))
		${SH_SLEEP} 1
	done
	logThis "File $1 copied successfully." "T" "$FUNCNAME"
}

transfer_debug() {
	username=$3
	host=$4
	[ -z "$1" ] && err 10 "source"
	[ ! -e "$srcFile" ] && err 8 "$srcFile"
	${SH_ECHO} "${SH_SCP} -Bq $1 $3@$4:$2"
}

checkDep() {
	[ "$debug" -gt "0" ] && logThis "Checking dependency for $1..." "T" "$FUNCNAME"
	if [ -e "$1" ]; then
		[ "$debug" -gt "0" ] && logThis "Dependency $1 found. It is safe to continue." "T" "$FUNCNAME"
	else
		logThis "Dependency not $1 found. This will set \$errKill to '1' (currently: \$errKill=$errKill) ending the script at next stage." "W" "$FUNCNAME"
		errKill=1
		err 5 "$1"
	fi
}

function displaytime {
	local T=$1
#	local Y=$((T/60/60/24/365))
	local D=$((T/60/60/24))
	local H=$((T/60/60%24))
	local M=$((T/60%60))
	local S=$((T%60))
#	(( $Y > 0 )) && ${SH_PRINTF} '%d years ' $Y
	(( $D > 0 )) && ${SH_PRINTF} '%d days ' $D
	(( $H > 0 )) && ${SH_PRINTF} '%d hours ' $H
	(( $M > 0 )) && ${SH_PRINTF} '%d minutes ' $M
	(( $D > 0 || $H > 0 || $M > 0 )) && ${SH_PRINTF} 'and %d seconds\n' $S || ${SH_PRINTF} '\e[0;33m%d seconds\e[0m\n' $S
#(( $D > 3 )) && dWarn=1

xT=$(( $sTime - $ntfHr * 3600))
lT=$(( $sTime - $T))

(( $xT > $lT )) && hWarn=1 || hWarn=0
return "$hWarn"
}

scriptEnd() {
	##################################################################
	#
	#  Destroy notify lock. Errors will exit program early
	#  so if the script survived here, all is well and notify
	#  lock can be removed if $waitThisLong seconds
	#  have passed. $waitThisLong is to stop error messages
	#  from flooding the recipient.
	#
	logThis "Checking for lock file ($trckErr)..." "T" "$FUNCNAME"
	if [ -f "$trckErr" ]; then
		mTime=$(${SH_STAT} -c %Y "$trckErr")
		logThis "Lock file ($trckErr) found (origin time: $mTime)." "T" "$FUNCNAME"
	else
		mTime=0
		logThis "Lock file ($trckErr) not found." "T" "$FUNCNAME"
	fi
	timeDiff=$(( sTime - mTime ))
	logThis "Lock file age: $timeDiff sec(s). The lock will be removed when $waitThisLong sec(s) of age." "T" "$FUNCNAME"
	if [ -a $trckErr ]; then
		if [ "$timeDiff" -ge "$waitThisLong" ]; then
			logThis "Removing lock file ($trckErr)..." "T" "$FUNCNAME"
			if ${SH_RM} "$trckErr" &> /dev/null; then
				logThis "Lock file ($trckErr) removed." "T" "$FUNCNAME"
			else
				logThis "Unable to remove lock file ($trckErr)." "W" "$FUNCNAME"
			fi
		else
			logThis "Lock file ($trckErr) left untouched (not removed)." "T" "$FUNCNAME"
			err "4" "$timeDiff"
		fi
	fi
	logThis "Lock file ($trckErr) manipulation executed succesfully." "T" "$FUNCNAME"
	logThis "Notifying leftovers... [ ==> ntfy() ]" "T" "$FUNCNAME"
	ntfy "$msg" "$title"
	#
	##################################################################

	#endTme=$(date +%s.%N)
#	dt=$(${SH_ECHO} "$endTme - $strtTme" | bc)
#	dd=$(${SH_ECHO} "$dt/86400" | bc)
#	dt2=$(${SH_ECHO} "$dt-86400*$dd" | bc)
#	dh=$(${SH_ECHO} "$dt2/3600" | bc)
#	dt3=$(${SH_ECHO} "$dt2-3600*$dh" | bc)
#	dm=$(${SH_ECHO} "$dt3/60" | bc)
#	ds=$(${SH_ECHO} "$dt3-60*$dm" | bc)
#	printf "Total runtime: %d:%02d:%02d:%02.4f\n" $dd $dh $dm $ds
	#${SH_LOGGER} "Total runtime: %d:%02d:%02d:%02.4f\n $dd $dh $dm $ds"
	exit 0
}
#
# Functions end.
#
#################################

#################################
#
#	post-functions
#
	logThis "Executive user: $(${SH_WHOAMI})" "T"
	logThis "PushBullet binary: ${SH_PUSHBULLET}" "T"
#
#################################
